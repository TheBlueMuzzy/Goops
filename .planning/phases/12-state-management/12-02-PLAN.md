---
phase: 12-state-management
plan: 02
type: execute
---

<objective>
Create GameStateManager interface and consolidate remaining state access patterns.

Purpose: Provide a clean interface for state access that can be used consistently across the codebase.
Output: GameStateManager type, cleaner state access patterns, updated documentation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior plan context:**
@.planning/phases/12-state-management/12-01-SUMMARY.md

**Key files:**
@core/GameEngine.ts
@hooks/useGameEngine.ts
@types.ts

**Established patterns:**
- GameEngine has public `state` property that components read
- Commands access `engine.state` directly
- React components get state via `useGameEngine` hook

**Constraints:**
- All 81 tests must pass
- No gameplay changes
- Keep it simple - don't over-engineer
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GameStateManager interface</name>
  <files>types.ts</files>
  <action>
Add a TypeScript interface that defines the contract for state management. This documents what operations are available and makes the API explicit:

```typescript
// State management interface - defines how components interact with game state
export interface GameStateManager {
    // Read-only state access
    readonly state: GameState;
    readonly isSessionActive: boolean;

    // State change notification
    subscribe(listener: () => void): () => void;

    // Command execution
    execute(command: Command): void;
}
```

This interface captures what GameEngine already provides. It's documentation more than new code - it makes the implicit contract explicit.

Note: Don't change GameEngine to implement this interface yet - that's optional cleanup. The interface itself is the valuable artifact.
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>GameStateManager interface defined in types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Clean up remaining prop drilling in ConsoleView</name>
  <files>Game.tsx, components/ConsoleView.tsx</files>
  <action>
Review ConsoleView props that could use events instead:

**Current ConsoleView props from Game.tsx:**
- `engine` - Needed for command execution (keep)
- `state` - Needed for rendering (keep)
- `totalScore`, `powerUpPoints`, `powerUps` - App-level data (keep)
- `onOpenSettings`, `onOpenHelp`, `onOpenUpgrades` - UI actions (could be events)
- `onSetRank`, `onPurchaseUpgrade` - Dev/upgrade actions (could be events)
- `onDismissGameOver` - Session action (keep - uses engine)

**Decision:** These callbacks go UP to App.tsx, not down into the component tree. They're not prop drilling in the problematic sense (passing through intermediate components). Leave them as is.

Instead, document this decision and verify the existing prop structure is correct.

**Verify no intermediate prop drilling remains:**
1. Check Game.tsx → GameBoard.tsx - callbacks should be removed (from Plan 01)
2. Check Game.tsx → ConsoleView.tsx - callbacks go to App.tsx (appropriate)
3. Check Game.tsx → Controls.tsx - minimal props (appropriate)

If all patterns are clean, add a comment in Game.tsx documenting the state/event architecture:

```typescript
// STATE ARCHITECTURE:
// - Game state flows down: useGameEngine → state prop → child components
// - Input events flow up: useInputHandlers → EventBus → Game.tsx → Commands
// - UI callbacks go to App.tsx: onOpenSettings, onSetRank, etc. (parent control)
```
  </action>
  <verify>npm run test:run passes, code review confirms clean patterns</verify>
  <done>Prop patterns documented, no unnecessary prop drilling remains</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Event-based input system and state management interface</what-built>
  <how-to-verify>
    1. Run: npm run dev -- --host
    2. Open game on phone or desktop
    3. Start a run and verify:
       - Rotation (Q/E or touch) works
       - Horizontal movement (drag or A/D) works
       - Soft drop (S or touch hold) works
       - Swap (R or touch) works
       - Block tap (touch block) works
       - Swipe up to console works
    4. Verify console controls still work
    5. Confirm no console errors
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` - No TypeScript errors
- [ ] `npm run test:run` - All 81 tests pass
- [ ] GameStateManager interface exists in types.ts
- [ ] State architecture documented in Game.tsx
- [ ] Human verified input handling works correctly
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- GameStateManager interface provides clear documentation
- Phase 12 complete - state management improved, prop drilling reduced
</success_criteria>

<output>
After completion, create `.planning/phases/12-state-management/12-02-SUMMARY.md`:

# Plan 12-02 Summary: State Management Interface

**[One-liner about what shipped]**

## Accomplishments
- GameStateManager interface defined
- State architecture documented
- Prop patterns reviewed and confirmed clean

## Files Created/Modified
- `types.ts` - Added GameStateManager interface
- `Game.tsx` - Added architecture documentation

## Phase 12 Complete
Both plans in Phase 12 (State Management & Events) complete:
- Plan 12-01: Input events added, prop drilling reduced
- Plan 12-02: State interface defined, architecture documented
</output>
