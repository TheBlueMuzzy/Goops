---
phase: 21-piece-shapes
plan: 03
type: execute
---

<objective>
Implement pressure-based piece spawning with corruption and mirroring.

Purpose: Replace the current random tetromino spawning with pressure-zone-based size selection.
Output: Spawn system that selects Tetra/Penta/Hexa based on game time, with 15% corruption and 50% mirror chance.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-piece-shapes/21-RESEARCH.md
@.planning/phases/21-piece-shapes/21-01-SUMMARY.md
@.planning/phases/21-piece-shapes/21-02-SUMMARY.md

**Key implementation file:**
@src/core/GameEngine.ts

**Dependencies from prior plans:**
- INITIAL_TIME_MS = 75000 (75 seconds)
- TETRA_ZONE_END_ROW = 13, PENTA_ZONE_END_ROW = 8
- CORRUPTION_CHANCE = 0.15, MIRROR_CHANCE = 0.5
- TETRA_NORMAL, TETRA_CORRUPTED, PENTA_NORMAL, PENTA_CORRUPTED, HEXA_NORMAL, HEXA_CORRUPTED arrays

**Zone timing (from STATE.md decisions):**
| Zone | Time | Pressure Row | Pieces |
|------|------|--------------|--------|
| Tetra | 0-25s | Start → row 13 | TETRA_PIECES |
| Penta | 25-50s | Row 13 → row 8 | PENTA_PIECES |
| Hexa | 50-75s | Row 8 → end | HEXA_PIECES |

**Spawn mechanics:**
1. Calculate elapsed time from (INITIAL_TIME_MS - timeLeft)
2. Determine zone based on elapsed time (0-25s = Tetra, 25-50s = Penta, 50-75s = Hexa)
3. Select normal or corrupted pool (15% corruption chance)
4. Pick random piece from pool
5. Apply mirror transform for asymmetric pieces (50% chance)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add piece pool selection helper</name>
  <files>src/core/GameEngine.ts</files>
  <action>
Add a new method `getPiecePoolByZone()` in GameEngine that returns the appropriate piece pool based on elapsed time.

```typescript
import {
  TETRA_NORMAL, TETRA_CORRUPTED,
  PENTA_NORMAL, PENTA_CORRUPTED,
  HEXA_NORMAL, HEXA_CORRUPTED,
  CORRUPTION_CHANCE, INITIAL_TIME_MS
} from '../constants';

/**
 * Get the appropriate piece pool based on elapsed game time.
 * Zone selection: Tetra (0-25s), Penta (25-50s), Hexa (50-75s)
 */
private getPiecePoolByZone(): PieceDefinition[] {
  const elapsedMs = INITIAL_TIME_MS - this.state.timeLeft;
  const elapsedSec = elapsedMs / 1000;

  // Determine which size zone we're in
  // 75 sec game = 25 sec per zone
  const zoneLength = INITIAL_TIME_MS / 3 / 1000; // 25 seconds

  // Use corruption chance to select normal vs corrupted
  const useCorrupted = Math.random() < CORRUPTION_CHANCE;

  if (elapsedSec < zoneLength) {
    // Tetra zone (0-25s)
    return useCorrupted ? TETRA_CORRUPTED : TETRA_NORMAL;
  } else if (elapsedSec < zoneLength * 2) {
    // Penta zone (25-50s)
    return useCorrupted ? PENTA_CORRUPTED : PENTA_NORMAL;
  } else {
    // Hexa zone (50-75s)
    return useCorrupted ? HEXA_CORRUPTED : HEXA_NORMAL;
  }
}
```

This keeps the zone selection logic isolated and testable.
  </action>
  <verify>TypeScript compiles. Method exists in GameEngine.</verify>
  <done>getPiecePoolByZone() returns correct pool based on elapsed time and corruption chance</done>
</task>

<task type="auto">
  <name>Task 2: Add piece mirroring helper</name>
  <files>src/core/GameEngine.ts</files>
  <action>
Add a helper to mirror piece coordinates horizontally. This creates visual variety without adding more piece definitions.

```typescript
import { MIRROR_CHANCE } from '../constants';

/**
 * Mirror a piece's cells horizontally (flip around Y axis).
 * Only applies to asymmetric pieces based on MIRROR_CHANCE.
 */
private maybeApplyMirror(definition: PieceDefinition): PieceDefinition {
  // 50% chance to mirror
  if (Math.random() >= MIRROR_CHANCE) {
    return definition;
  }

  // Check if piece is symmetric (mirroring would have no effect)
  // A piece is symmetric if for every cell (x, y), there exists (-x, y)
  const isSymmetric = definition.cells.every(cell =>
    definition.cells.some(other => other.x === -cell.x && other.y === cell.y)
  );

  if (isSymmetric) {
    return definition;
  }

  // Apply horizontal mirror: negate x coordinates
  return {
    ...definition,
    cells: definition.cells.map(cell => ({ x: -cell.x, y: cell.y }))
  };
}
```

This doubles the effective variety without doubling the piece definitions.
  </action>
  <verify>TypeScript compiles. Method exists in GameEngine.</verify>
  <done>maybeApplyMirror() returns mirrored piece 50% of time for asymmetric pieces</done>
</task>

<task type="auto">
  <name>Task 3: Update spawnNewPiece to use zone-based selection</name>
  <files>src/core/GameEngine.ts</files>
  <action>
Modify the existing `spawnNewPiece()` method to use the new zone-based piece selection instead of the old PIECES array.

**Current flow (around line 567-680):**
1. Calculate rank
2. Get color palette
3. Pick from PIECES array
4. Apply color bias, multi-color split, wild pieces
5. Spawn at center

**New flow:**
1. Calculate rank
2. Get color palette
3. **NEW:** Get piece pool from `getPiecePoolByZone()` instead of using PIECES
4. Pick random piece from pool
5. **NEW:** Apply `maybeApplyMirror()` to the selected piece
6. Apply existing color logic (bias, split, wild)
7. Spawn at center

Find the line that currently does:
```typescript
const pieceIndex = Math.floor(Math.random() * PIECES.length);
let definition = { ...PIECES[pieceIndex] };
```

Replace with:
```typescript
const pool = this.getPiecePoolByZone();
const pieceIndex = Math.floor(Math.random() * pool.length);
let definition = this.maybeApplyMirror({ ...pool[pieceIndex] });
```

**Important:**
- Keep ALL existing color logic (color bias, multi-color split, wild pieces)
- Only change HOW the base piece is selected
- The piece definition still needs to have its color assigned after selection
- Don't break nextPiece queue logic

**Edge case:** The first piece spawns before any time has elapsed (timeLeft === INITIAL_TIME_MS). This correctly puts it in Tetra zone since elapsedSec would be 0.
  </action>
  <verify>`npm run test:run` passes. Start a game and verify pieces spawn. Check that piece sizes change as time progresses.</verify>
  <done>spawnNewPiece() uses zone-based selection with corruption and mirroring</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Pressure-based piece spawning system with 3 size zones, 15% corruption, and 50% mirroring</what-built>
  <how-to-verify>
    1. Run: `npm run dev -- --host`
    2. Start a new game at any rank
    3. **First 25 seconds (Tetra zone):**
       - Pieces should all be 4-cell tetrominoes
       - Some may look unusual (corrupted variants with gaps)
       - Watch for mirrored variants of L and S shapes
    4. **25-50 seconds (Penta zone):**
       - Pieces transition to 5-cell pentominoes
       - Noticeably larger, more varied shapes
       - Plus-shaped pieces, longer lines, etc.
    5. **50-75 seconds (Hexa zone):**
       - Pieces become 6-cell hexominoes
       - Largest pieces, complex shapes
       - Game ends at 75 seconds
    6. Confirm: Ghost piece displays correctly for all sizes
    7. Confirm: Pieces lock correctly (no visual glitches)
    8. Confirm: Multi-color splits still work (at rank 20+)
  </how-to-verify>
  <resume-signal>Type "approved" if all piece sizes spawn correctly by zone, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:run` passes
- [ ] `npm run build` succeeds
- [ ] Tetra pieces spawn in first 25 seconds
- [ ] Penta pieces spawn from 25-50 seconds
- [ ] Hexa pieces spawn from 50-75 seconds
- [ ] Corrupted variants appear ~15% of the time
- [ ] Asymmetric pieces appear mirrored ~50% of the time
- [ ] Ghost piece renders correctly for all piece sizes
- [ ] Multi-color splits still work
- [ ] Wild pieces still work (rank 40+)
</verification>

<success_criteria>
- All tasks completed
- Human verification approved
- No TypeScript errors
- Tests pass
- Phase 21 complete
</success_criteria>

<output>
After completion, create `.planning/phases/21-piece-shapes/21-03-SUMMARY.md`

This is the final plan for Phase 21. After completion:
- Phase 21 (Piece Shapes) is complete
- v1.3 milestone has 1 phase complete
</output>
