---
phase: 33-rank-0-training-sequence
plan: 01
type: execute
---

<objective>
Define the training scenario data model and create all 6 training scenario configurations.

Purpose: Establish the type system and configuration data for constrained training levels at rank 0. Each scenario teaches exactly one mechanic through gameplay constraints — fewer colors, simpler pieces, specific goals, and longer/infinite time limits.

Output: `src/types/training.ts` (types) and `src/data/trainingScenarios.ts` (6 scenario configs)
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context:
@.planning/phases/31-tutorial-infrastructure/31-01-SUMMARY.md
@.planning/phases/32-journal-system/32-01-SUMMARY.md

# Relevant source files:
@src/types/tutorial.ts
@src/data/tutorialSteps.ts
@src/data/journalEntries.ts
@src/core/GameEngine.ts
@src/utils/gameLogic.ts

**Established patterns:**
- TutorialStepId union type for step identification
- TutorialStep with trigger + IntercomMessage format
- JournalPageId union type for journal pages
- GameEngine.startRun() handles game initialization
- getPaletteForRank() returns color arrays
- createInitialGrid() handles starting junk

**Constraining decisions:**
- Phase 31: Tutorial triggers use discriminated unions (ON_RANK_REACH, ON_EVENT, ON_GAME_START, ON_FIRST_ACTION, MANUAL)
- Phase 31: IntercomMessage = { keywords: string[], fullText: string }
- Phase 32: Journal pages unlock by TutorialStepId
- Phase 32: TutorialStepId already includes WELCOME, ROTATE_INTRO, DROP_INTRO, CRACK_INTRO, POP_TIMING, WRAP_INTRO, FIRST_SHIFT
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define TrainingScenario types</name>
  <files>src/types/training.ts</files>
  <action>
Create a new types file for the training system. Define:

1. `TrainingScenarioId` string literal union: `'0TA' | '0TB' | '0TC' | '0TD' | '0TE' | '0TF'`

2. `TrainingConfig` interface — the constraints applied to GameEngine:
   - `palette: string[]` — override available colors (e.g., ['RED'] for rotation-only)
   - `maxPieceSize: number` — max cells per piece (1=Mono, 2=Duo, 3=Tri, 4=Tetra). Pieces above this size are excluded from spawn pool
   - `goalsTarget: number` — cracks to seal for scenario completion
   - `timeLimitMs: number | null` — null = no time limit (early training), number = ms
   - `startingJunk: number` — override junk count (0 for early training)
   - `allowRotation: boolean` — can player rotate pieces (Q/E)? (true for all except maybe 0TA)
   - `gridPreset?: string` — optional named preset for pre-placed grid content (for wrapping scenario)

3. `TrainingScenario` interface:
   - `id: TrainingScenarioId`
   - `order: number` — sequence position (1-6)
   - `name: string` — display name (e.g., "Rotation Training")
   - `objective: string` — player-facing objective text (e.g., "Seal 2 cracks by rotating the tank")
   - `concept: string` — internal label for what this teaches
   - `config: TrainingConfig` — game constraints
   - `tutorialStepId: TutorialStepId` — which tutorial step this scenario's intercom triggers
   - `completionStepId: TutorialStepId` — which step gets marked complete when scenario is done

4. `TrainingSequence` type — ordered array: `TrainingScenario[]`

Import TutorialStepId from `../types/tutorial`. Keep types simple and human-readable — no generics or complex patterns.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/types/training.ts` (or run full `npm run test:run`)</verify>
  <done>Types file exists with all 4 type definitions, imports resolve, no TS errors</done>
</task>

<task type="auto">
  <name>Task 2: Create training scenario configurations</name>
  <files>src/data/trainingScenarios.ts</files>
  <action>
Create the 6 training scenario configs. Import types from `../types/training` and color constants from wherever the game defines them (likely palette utils or constants).

**Scenario 0TA — "Tank Rotation"**
- Teaches: Rotating the tank (swipe / A / D keys)
- palette: ['RED'] (1 color — no color-matching complexity)
- maxPieceSize: 1 (Mono only — no piece rotation needed)
- goalsTarget: 2 (2 red cracks placed on different sides of the tank)
- timeLimitMs: null (no time pressure — player can take as long as needed)
- startingJunk: 0
- allowRotation: true (piece rotation, though irrelevant for mono)
- tutorialStepId: 'WELCOME' (first intercom plays at start)
- completionStepId: 'ROTATE_INTRO'
- objective: "Find and seal 2 cracks by rotating the tank"

**Scenario 0TB — "Piece Placement"**
- Teaches: Piece rotation (Q/E), soft drop, hard drop
- palette: ['RED'] (still 1 color)
- maxPieceSize: 3 (Tri pieces — enough to need rotation)
- goalsTarget: 3
- timeLimitMs: null (still no time pressure)
- startingJunk: 0
- allowRotation: true
- tutorialStepId: 'DROP_INTRO'
- completionStepId: 'DROP_INTRO'
- objective: "Rotate and place pieces to seal 3 cracks"

**Scenario 0TC — "Color Matching"**
- Teaches: Goop must match crack color
- palette: ['RED', 'BLUE', 'GREEN'] (3 colors)
- maxPieceSize: 4 (Tetra pieces)
- goalsTarget: 3
- timeLimitMs: null
- startingJunk: 0
- allowRotation: true
- tutorialStepId: 'CRACK_INTRO'
- completionStepId: 'CRACK_INTRO'
- objective: "Match goop color to crack color to seal 3 cracks"

**Scenario 0TD — "Pop Timing"**
- Teaches: Scaffolding vs pressure tradeoff (build up goop to reach high cracks, but too much goop = danger)
- palette: ['RED', 'BLUE', 'GREEN'] (3 colors)
- maxPieceSize: 4
- goalsTarget: 4 (some cracks will be higher, requiring stacking)
- timeLimitMs: 60000 (60s — introduce time pressure)
- startingJunk: 0
- allowRotation: true
- tutorialStepId: 'POP_TIMING'
- completionStepId: 'POP_TIMING'
- objective: "Stack goop to reach high cracks — but watch the pressure"

**Scenario 0TE — "Cylindrical Wrapping"**
- Teaches: Tank wraps around — pieces on the edge continue on the other side
- palette: ['RED', 'BLUE'] (2 colors — keep simple)
- maxPieceSize: 4
- goalsTarget: 3
- timeLimitMs: null (back to no time pressure for this concept)
- startingJunk: 0
- allowRotation: true
- gridPreset: 'WRAP_DEMO' (optional — could pre-place junk near edges to make wrapping obvious)
- tutorialStepId: 'WRAP_INTRO'
- completionStepId: 'WRAP_INTRO'
- objective: "Cracks span the tank's edge — use wrapping to seal them"

**Scenario 0TF — "First Real Shift"**
- Teaches: Putting it all together in a real game
- palette: ['RED', 'BLUE', 'GREEN', 'YELLOW'] (full rank 0 palette)
- maxPieceSize: 4 (Tetra zone only — no penta/hexa yet)
- goalsTarget: 4 (standard rank 0)
- timeLimitMs: 75000 (full 75s game)
- startingJunk: 0
- allowRotation: true
- tutorialStepId: 'FIRST_SHIFT'
- completionStepId: 'FIRST_SHIFT'
- objective: "Complete your first real shift"

Export as `TRAINING_SCENARIOS: TrainingScenario[]` (ordered by `order` field).
Also export a helper: `getNextTrainingScenario(completedSteps: string[]): TrainingScenario | null` — returns the first scenario whose `completionStepId` is NOT in completedSteps, or null if all complete.
Also export: `isTrainingComplete(completedSteps: string[]): boolean` — true if all 6 completionStepIds are in completedSteps.
  </action>
  <verify>Run `npm run test:run` — all existing tests pass, no TS errors</verify>
  <done>6 scenarios defined with constraints, helper functions exported, no TS errors, all existing tests pass</done>
</task>

<task type="checkpoint:decision" gate="blocking">
  <decision>Training scenario design review</decision>
  <context>These 6 scenarios define the entire rank 0 experience. Review the constraints before we wire them into the game engine. Key questions: Are the learning progressions right? Should any scenario have different constraints? Is 6 scenarios the right number?</context>
  <options>
    <option id="approve">
      <name>Approve scenarios as-is</name>
      <pros>Well-structured progression, each teaches one concept, constraints escalate naturally</pros>
      <cons>May need tweaking after playtesting</cons>
    </option>
    <option id="adjust">
      <name>Adjust scenarios</name>
      <pros>Can fine-tune before engine integration</pros>
      <cons>Delays implementation</cons>
    </option>
  </options>
  <resume-signal>Select: approve or adjust (with details)</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:run` passes all existing tests
- [ ] No TypeScript errors
- [ ] Both new files import/export correctly
- [ ] getNextTrainingScenario and isTrainingComplete helpers work logically
</verification>

<success_criteria>

- TrainingScenario types defined and importable
- 6 training scenarios configured with gameplay constraints
- Helper functions for sequence progression
- User has reviewed and approved scenario designs
- All existing tests still pass
  </success_criteria>

<output>
After completion, create `.planning/phases/33-rank-0-training-sequence/33-01-SUMMARY.md`
</output>
