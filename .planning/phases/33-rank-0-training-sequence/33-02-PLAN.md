---
phase: 33-rank-0-training-sequence
plan: 02
type: execute
---

<objective>
Add training mode to GameEngine and build the training flow controller that sequences players through scenarios.

Purpose: The game engine needs to accept training constraints (limited palette, piece sizes, goals, time) and the app needs a controller that manages the training sequence — starting the right scenario, detecting completion, advancing to the next, and graduating the player to rank 1.

Output: Modified GameEngine with `startTraining()` method, new `useTrainingFlow` hook for sequence management, Game.tsx integration
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context:
@.planning/phases/31-tutorial-infrastructure/31-01-SUMMARY.md
@.planning/phases/31-tutorial-infrastructure/31-03-SUMMARY.md
@.planning/phases/33-rank-0-training-sequence/33-01-SUMMARY.md

# Relevant source files:
@src/types/training.ts
@src/data/trainingScenarios.ts
@src/core/GameEngine.ts
@src/utils/gameLogic.ts
@src/hooks/useTutorial.ts
@src/components/Game.tsx
@src/components/App.tsx

**Established patterns:**
- GameEngine.startRun() initializes game state
- getPaletteForRank() returns color arrays
- createInitialGrid() handles starting junk
- devOverrideNextGoop exists for piece forcing
- useTutorial hook manages tutorial state and persistence
- Game.tsx passes saveData + setSaveData to hooks
- gameEventBus for event communication

**Constraining decisions:**
- Phase 31: Tutorial uses SaveData.tutorialProgress.completedSteps for persistence
- Phase 33-01: TrainingConfig defines palette, maxPieceSize, goalsTarget, timeLimitMs, startingJunk, allowRotation, gridPreset
- Phase 33-01: getNextTrainingScenario() and isTrainingComplete() helpers exist
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add training mode to GameEngine</name>
  <files>src/core/GameEngine.ts, src/utils/gameLogic.ts</files>
  <action>
Add a `startTraining(config: TrainingConfig)` method to GameEngine that initializes a constrained game session:

1. **Import** TrainingConfig from `../types/training`

2. **Add property** `isTrainingMode: boolean = false` to GameEngine

3. **Create `startTraining(config: TrainingConfig)`** method that:
   - Sets `isTrainingMode = true`
   - Sets `palette` to `config.palette` (bypass getPaletteForRank)
   - Sets `goalsTarget` to `config.goalsTarget`
   - Sets shift time: if `config.timeLimitMs` is null, use a very large number (999999ms — effectively infinite). If number, use that value
   - Calls `createInitialGrid()` with `startingJunk: config.startingJunk` (may need to add junk count param to createInitialGrid or handle inline)
   - Spawns first piece respecting `config.maxPieceSize` constraint

4. **Constrain piece spawning**: Modify the piece selection logic to filter by `maxPieceSize` when in training mode. The simplest approach: add a `maxPieceSize: number | null` property to GameEngine (null = no limit). When spawning a piece, if maxPieceSize is set, filter the piece pool to only include pieces with cell count <= maxPieceSize. Set this from `config.maxPieceSize` in startTraining, reset to null in startRun.

5. **Handle training completion**: When all cracks are sealed (goalsTarget reached) in training mode, emit a `TRAINING_SCENARIO_COMPLETE` event via gameEventBus instead of (or in addition to) the normal win flow. Add this event type to the events system.

Do NOT modify the existing `startRun()` flow — training mode is a parallel path. Keep startRun untouched for normal gameplay.

Do NOT add the gridPreset system yet — that's a stretch goal. Just set startingJunk to 0 for most scenarios.
  </action>
  <verify>Run `npm run test:run` — all existing tests pass. Manually verify GameEngine has startTraining method and maxPieceSize filtering by reading the file.</verify>
  <done>GameEngine.startTraining() exists, piece spawning respects maxPieceSize, TRAINING_SCENARIO_COMPLETE event fires on completion, all existing tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Build training flow controller and wire into Game.tsx</name>
  <files>src/hooks/useTrainingFlow.ts, src/components/Game.tsx</files>
  <action>
Create `useTrainingFlow` hook that manages the training sequence:

1. **Hook signature**: `useTrainingFlow(saveData: SaveData, setSaveData: (fn) => void, gameEngine: GameEngine | null)`

2. **State**:
   - `currentScenario: TrainingScenario | null` — derived from getNextTrainingScenario(saveData.tutorialProgress.completedSteps)
   - `isInTraining: boolean` — true if player is rank 0 AND training is not complete

3. **Core logic**:
   - `startNextScenario()`: Gets next scenario from getNextTrainingScenario, calls gameEngine.startTraining(scenario.config)
   - `completeCurrentScenario()`: Marks the scenario's completionStepId as complete in saveData.tutorialProgress.completedSteps, checks if training is now complete
   - `isTrainingDone`: Computed from isTrainingComplete(completedSteps)

4. **Event handling**: Subscribe to TRAINING_SCENARIO_COMPLETE event. When received, call completeCurrentScenario(). If training is now complete, don't do anything special — the next game start will use startRun() instead of startTraining() because isTrainingComplete will return true.

5. **Return**: `{ currentScenario, isInTraining, startNextScenario, isTrainingDone }`

**Wire into Game.tsx:**

In Game.tsx, when the player starts a game at rank 0:
- Check `isInTraining` from useTrainingFlow
- If true: call `startNextScenario()` instead of the normal `gameEngine.startRun()`
- If false (training complete): use normal `startRun()` flow

The hook should be used alongside the existing useTutorial hook — they work together. useTutorial handles intercom messages, useTrainingFlow handles scenario sequencing.

Keep integration minimal — don't restructure Game.tsx. Just add the training check at the game start point.
  </action>
  <verify>Run `npm run test:run` — all existing tests pass. Verify hook file exists and Game.tsx has training integration.</verify>
  <done>useTrainingFlow hook manages scenario progression, Game.tsx starts training scenarios at rank 0, completion advances to next scenario, all existing tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:run` passes all existing tests
- [ ] No TypeScript errors
- [ ] GameEngine.startTraining() correctly applies constraints
- [ ] useTrainingFlow correctly sequences scenarios
- [ ] Game.tsx starts training mode at rank 0
- [ ] TRAINING_SCENARIO_COMPLETE event exists and fires
</verification>

<success_criteria>

- GameEngine has parallel training path (startTraining) alongside normal play (startRun)
- Piece spawning respects maxPieceSize constraint
- Training flow controller sequences through 6 scenarios
- Completing all scenarios allows normal gameplay at rank 0+
- Minimal changes to existing code — no regressions
  </success_criteria>

<output>
After completion, create `.planning/phases/33-rank-0-training-sequence/33-02-SUMMARY.md`
</output>
