---
phase: 11-gameengine-refactor
plan: 02
type: execute
---

<objective>
Extract ComplicationManager and GoalManager classes from GameEngine to improve separation of concerns.

Purpose: Move complication and goal logic into focused manager classes, reducing GameEngine responsibilities.
Output: Two new manager classes in core/, GameEngine delegating to managers.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan summary:
@.planning/phases/11-gameengine-refactor/11-01-SUMMARY.md

# Key source files:
@core/GameEngine.ts
@core/events/EventBus.ts
@complicationConfig.ts

**Constraints:**
- All 81 tests must pass
- No gameplay changes
- Managers should follow existing patterns (see EventBus for reference)

**Established patterns:**
- EventBus is a singleton exported from core/events/
- Commands access engine via execute(engine) pattern
- State lives in GameEngine, managers operate on state passed to them
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract ComplicationManager</name>
  <files>core/ComplicationManager.ts, core/GameEngine.ts</files>
  <action>
Create `core/ComplicationManager.ts` with complication-related logic:

```typescript
// core/ComplicationManager.ts
import { GameState, ComplicationType, Complication } from '../types';
import { COMPLICATION_CONFIG, calculateCooldownMs, isComplicationUnlocked } from '../complicationConfig';
import { calculateRankDetails } from '../utils/progression';
import { gameEventBus } from './events/EventBus';
import { GameEventType } from './events/GameEvents';
import { audio } from '../utils/audio';

export class ComplicationManager {
    /**
     * Check and spawn complications based on current state
     */
    checkComplications(
        state: GameState,
        initialTotalScore: number,
        lastCheckTime: number
    ): { spawned: ComplicationType | null; newLastCheckTime: number } {
        // Move checkComplications() logic here
        // Return spawned type (if any) and updated lastCheckTime
    }

    /**
     * Spawn a new complication of the given type
     */
    spawnComplication(state: GameState, type: ComplicationType): Complication {
        // Move spawnComplication() logic here
        // Return the new complication object
    }

    /**
     * Resolve an active complication
     */
    resolveComplication(
        state: GameState,
        complicationId: string,
        initialTotalScore: number,
        powerUps: Record<string, number>
    ): void {
        // Move resolveComplication() logic here
        // Mutates state directly (same pattern as GameEngine)
    }

    /**
     * Check LIGHTS trigger condition on piece lock
     */
    checkLightsTrigger(
        state: GameState,
        initialTotalScore: number,
        maxTime: number,
        powerUps: Record<string, number>,
        grid: GridCell[][]
    ): boolean {
        // Move LIGHTS trigger logic from tickActivePiece()
        // Return true if LIGHTS should spawn
    }
}

export const complicationManager = new ComplicationManager();
```

In GameEngine:
- Import complicationManager
- Replace checkComplications() call with: `complicationManager.checkComplications(...)`
- Replace spawnComplication() with manager call
- Replace resolveComplication() with manager call
- Update tickActivePiece() to use checkLightsTrigger()
- Remove the extracted private methods

The manager operates on state passed to it (doesn't own state).
  </action>
  <verify>
1. `npx tsc --noEmit` — no TypeScript errors
2. `npm run test:run` — all 81 tests pass
  </verify>
  <done>ComplicationManager extracted with checkComplications, spawnComplication, resolveComplication, checkLightsTrigger</done>
</task>

<task type="auto">
  <name>Task 2: Extract GoalManager</name>
  <files>core/GoalManager.ts, core/GameEngine.ts</files>
  <action>
Create `core/GoalManager.ts` with goal-related logic:

```typescript
// core/GoalManager.ts
import { GameState, GoalMark, ActivePiece, FloatingText, GridCell } from '../types';
import { spawnGoalMark } from '../utils/gameLogic';
import { normalizeX } from '../utils/gameLogic';
import { gameEventBus } from './events/EventBus';
import { GameEventType } from './events/GameEvents';

export class GoalManager {
    /**
     * Spawn a new goal mark if conditions are met
     */
    trySpawnGoal(
        state: GameState,
        grid: GridCell[][],
        currentRank: number,
        timeLeft: number,
        maxTime: number,
        lastSpawnTime: number,
        spawnInterval: number
    ): { goal: GoalMark | null; newLastSpawnTime: number } {
        // Move tickGoals() spawning logic here
    }

    /**
     * Handle consumed and destroyed goals after piece lock
     */
    handleGoals(
        state: GameState,
        consumed: string[],
        destroyed: string[],
        piece: ActivePiece
    ): void {
        // Move handleGoals() logic here
        // Creates floating text, emits events
    }
}

export const goalManager = new GoalManager();
```

In GameEngine:
- Import goalManager
- Replace tickGoals() internals with: `goalManager.trySpawnGoal(...)`
- Replace handleGoals() with: `goalManager.handleGoals(...)`
- Remove the extracted methods

Keep tickGoals() as a thin wrapper that calls the manager and updates lastGoalSpawnTime.
  </action>
  <verify>
1. `npx tsc --noEmit` — no TypeScript errors
2. `npm run test:run` — all 81 tests pass
  </verify>
  <done>GoalManager extracted with trySpawnGoal and handleGoals</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Extracted ComplicationManager and GoalManager from GameEngine:
- ComplicationManager handles all complication spawning, checking, resolution
- GoalManager handles goal spawning and capture/destroy handling
- GameEngine delegates to managers for these concerns
  </what-built>
  <how-to-verify>
    1. Run: `npm run dev -- --host`
    2. Open on phone or desktop browser

    **Test Complications:**
    3. Play at rank 1+ to enable LASER complication
    4. Pop blocks until laser capacitor drains to 0
    5. Verify LASER complication triggers (alert appears)
    6. Solve the laser minigame
    7. Verify complication resolves (alert clears, capacitor refills)

    8. Play at rank 3+ to enable CONTROLS
    9. Rotate rapidly to build heat
    10. Verify CONTROLS triggers at 100 heat
    11. Solve the controls minigame
    12. Verify heat resets after resolution

    **Test Goals:**
    13. Watch for goal marks (yellow crack shapes) spawning every 5s
    14. Lock a piece on a goal mark
    15. Verify "CAPTURED!" floating text appears
    16. Verify goals counter increments

    **General:**
    17. Play a full game to win (clear all goals)
    18. Verify score, timer, all mechanics work
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:run` passes all 81 tests
- [ ] `npx tsc --noEmit` has no TypeScript errors
- [ ] ComplicationManager handles all complication logic
- [ ] GoalManager handles all goal logic
- [ ] Human verified gameplay works correctly
</verification>

<success_criteria>

- ComplicationManager.ts created (~120 lines)
- GoalManager.ts created (~50 lines)
- GameEngine.ts reduced in size
- All 81 tests pass
- No gameplay changes
</success_criteria>

<output>
After completion, create `.planning/phases/11-gameengine-refactor/11-02-SUMMARY.md` with:
- Line counts for new files
- GameEngine.ts line count change
- List of methods moved to each manager
</output>
