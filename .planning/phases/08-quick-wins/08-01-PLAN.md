# Plan 08-01: Quick Wins & Memory Fixes

## Goal

Fix critical low-risk issues identified in the v1.1 audit: memory leaks, hard-coded magic numbers, and missing memoization. These are quick wins that improve code quality with minimal risk.

## Scope

**In Scope:**
- Fix `rotationTimestamps` memory leak with circular buffer
- Extract hard-coded complication values to config
- Fix vbX/vbY/vbW/vbH memoization in GameBoard.tsx
- Extract coordinate transform utilities (testable)

**Out of Scope:**
- Large file decomposition (Phases 9-11)
- State management refactor (Phase 12)
- New features or gameplay changes

## Current State

### Memory Leak: rotationTimestamps
- **Location:** `types.ts:149`, `core/commands/actions.ts:45-48`
- **Problem:** Array grows unbounded, filter creates new arrays on every rotation
- **Evidence:** ~6000 allocations per session (from audit)
- **Current code:**
  ```ts
  engine.state.rotationTimestamps.push(now);
  engine.state.rotationTimestamps = engine.state.rotationTimestamps.filter(t => t > cutoff);
  ```

### Hard-coded Complication Values
- **Locations:** `core/GameEngine.ts:271-280`, `core/GameEngine.ts:331-339`
- **Problem:** Magic numbers scattered (unlock ranks, cooldown formula, trigger thresholds)
- **Evidence:** `rank >= 1`, `rank >= 3`, `Math.max(8, 20 - ...)` in multiple places

### Missing Memoization: vbX/vbY/vbW/vbH
- **Location:** `components/GameBoard.tsx:79-82`
- **Problem:** viewBox values recalculated on every render
- **Impact:** Minor performance overhead, code clarity issue

### Coordinate Transform Coupling
- **Location:** `components/GameBoard.tsx:100-150`
- **Problem:** Click-to-grid coordinate transform logic inline in component
- **Impact:** Untestable, hard to verify edge cases

## Implementation

### Task 1: Fix rotationTimestamps Memory Leak

**Strategy:** Replace unbounded array with fixed-size circular buffer

**Changes:**

1. Add constant to `constants.ts`:
   ```ts
   export const ROTATION_BUFFER_SIZE = 30; // Max rotations tracked (3s window at ~10 rotations/sec max)
   ```

2. Update `core/commands/actions.ts`:
   ```ts
   // Before: unbounded push + filter (allocates new array every time)
   engine.state.rotationTimestamps.push(now);
   engine.state.rotationTimestamps = engine.state.rotationTimestamps.filter(t => t > cutoff);

   // After: circular buffer (fixed allocation)
   engine.state.rotationTimestamps.push(now);
   if (engine.state.rotationTimestamps.length > ROTATION_BUFFER_SIZE) {
       engine.state.rotationTimestamps.shift();
   }
   ```

3. Note: The 3-second window filter is already applied in heat calculation, so buffer just needs size limit.

**Test:** Run existing tests, verify CONTROLS complication still triggers correctly.

### Task 2: Create complicationConfig.ts

**Strategy:** Single source of truth for all complication configuration

**Create `complicationConfig.ts`:**
```ts
import { ComplicationType } from '../types';

export const COMPLICATION_CONFIG = {
  [ComplicationType.LASER]: {
    unlockRank: 1,
    capacitorMax: 100,
    drainPerUnit: 4,  // Currently in Art.tsx popGoop
  },
  [ComplicationType.LIGHTS]: {
    unlockRank: 2,
    triggerChance: 0.5,  // 50%
    pressureGapMin: 3,
    pressureGapMax: 5,
  },
  [ComplicationType.CONTROLS]: {
    unlockRank: 3,
    heatMax: 100,
    heatPerRotation: 5,
    heatDissipationBase: 50,  // per second
  },
} as const;

export const COOLDOWN_CONFIG = {
  minSeconds: 8,
  maxSeconds: 20,
  // Formula: max(minSeconds, maxSeconds - (rank - unlockRank))
};
```

**Update references:**
- `core/GameEngine.ts:271-280` - Use `COMPLICATION_CONFIG[type].unlockRank`
- `core/GameEngine.ts:331-339` - Use unlock rank from config
- Any other hard-coded `rank >= N` checks

### Task 3: Memoize viewBox Values

**Strategy:** Use useMemo to cache viewBox calculations

**Location:** `components/GameBoard.tsx:79-82`

**Changes:**
```tsx
// Before: recalculated every render
const vbX = -projectedHalfWidth;
const vbY = 0;
const vbW = projectedHalfWidth * 2;
const vbH = VISIBLE_HEIGHT * BLOCK_SIZE;

// After: memoized
const { vbX, vbY, vbW, vbH } = useMemo(() => ({
  vbX: -projectedHalfWidth,
  vbY: 0,
  vbW: projectedHalfWidth * 2,
  vbH: VISIBLE_HEIGHT * BLOCK_SIZE,
}), [projectedHalfWidth]);
```

### Task 4: Extract Coordinate Transform Utilities

**Strategy:** Move coordinate transform logic to testable utility file

**Create `utils/coordinateTransform.ts`:**
```ts
/**
 * Convert screen coordinates to SVG viewBox coordinates
 * Handles preserveAspectRatio="xMidYMid slice" scaling
 */
export function screenToSvg(
  clientX: number,
  clientY: number,
  svgRect: DOMRect,
  viewBox: { x: number; y: number; w: number; h: number }
): { svgX: number; svgY: number } {
  const contentW = svgRect.width;
  const contentH = svgRect.height;
  const scaleX = contentW / viewBox.w;
  const scaleY = contentH / viewBox.h;
  const scale = Math.max(scaleX, scaleY); // slice mode uses max

  const renderedW = viewBox.w * scale;
  const offsetX = (renderedW - contentW) / 2;

  const relX = clientX - svgRect.left;
  const relY = clientY - svgRect.top;

  const svgX = viewBox.x + (relX - offsetX) / scale;
  const svgY = viewBox.y + relY / scale;

  return { svgX, svgY };
}

/**
 * Convert SVG coordinates to grid column/row
 */
export function svgToGrid(
  svgX: number,
  svgY: number,
  blockSize: number,
  boardOffset: number,
  totalWidth: number
): { col: number; row: number } {
  const rawCol = Math.floor(svgX / blockSize) + boardOffset;
  const col = ((rawCol % totalWidth) + totalWidth) % totalWidth; // Wrap for cylinder
  const row = Math.floor(svgY / blockSize);
  return { col, row };
}
```

**Update GameBoard.tsx:** Import and use these utilities instead of inline calculation.

## Verification

### Automated Tests
- All 65 existing tests must pass
- Add tests for `coordinateTransform.ts` edge cases (negative coords, wrapping)

### Manual Testing
- Verify CONTROLS complication still triggers after rotation spam
- Verify click-to-pop still works correctly
- Verify no performance regression on mobile

## Files Changed

| File | Change Type | Purpose |
|------|-------------|---------|
| `constants.ts` | Modify | Add ROTATION_BUFFER_SIZE |
| `complicationConfig.ts` | New | Centralize complication values |
| `core/commands/actions.ts` | Modify | Fix rotation buffer |
| `core/GameEngine.ts` | Modify | Use complicationConfig |
| `components/GameBoard.tsx` | Modify | Memoize viewBox, use coordinate utils |
| `utils/coordinateTransform.ts` | New | Testable coordinate transforms |
| `tests/coordinateTransform.test.ts` | New | Unit tests for transforms |

## Rollback

All changes are isolated. If issues arise:
1. Revert `complicationConfig.ts` usage - inline values work
2. Revert circular buffer - old filter approach works (just slower)
3. Revert memoization - no functional change
4. Revert coordinate utils - inline code still works

## Estimated Complexity

- Tasks are independent, can be done in any order
- Each task is low-risk, isolated change
- No cascading effects expected
