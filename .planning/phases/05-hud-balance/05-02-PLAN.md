---
phase: 05-hud-balance
plan: 02
type: execute
---

<objective>
Implement LASER capacitor meter logic — drains when player pops goop, triggers LASER complication when empty.

Purpose: Replace the cumulative counter trigger with a visible, draining meter that gives players feedback and control.
Output: Capacitor meter drains during gameplay, LASER triggers when it hits 0, meter refills on resolution.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/DESIGN_VISION.md
@.planning/phases/05-hud-balance/05-01-SUMMARY.md
@types.ts
@core/GameEngine.ts
@utils/gameLogic.ts

**Current LASER Trigger (to be replaced):**
- `totalUnitsPopped >= complicationThresholds.laser` (random 12-24 threshold)
- Checked every 1 second in checkComplications()
- Counter resets to 0 on resolution

**New LASER Trigger:**
- `laserCapacitor <= 0` triggers LASER complication
- Capacitor drains by X per unit popped (tunable value, start with ~4-5 per unit)
- Capacitor refills to 100 on LASER resolution
- Only drains at rank 1+ (LASER unlock rank)

**Key Files:**
- `utils/gameLogic.ts`: Contains `popGroup()` which handles group popping — this is where drain should occur
- `core/GameEngine.ts`: Contains `checkComplications()` and `resolveComplication()`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement capacitor drain on pop</name>
  <files>core/GameEngine.ts, utils/gameLogic.ts</files>
  <action>
Find where units are popped. This happens when the player taps/clicks on a group to pop it.

Look for where `totalUnitsPopped` is incremented — this is the same place capacitor should drain.

Add drain logic:
- `const drainAmount = unitsPopped * 4` (4 per unit, tunable)
- `state.laserCapacitor = Math.max(0, state.laserCapacitor - drainAmount)`

Only drain if rank >= 1 (LASER is unlocked at rank 1).

Do NOT add refill logic here — that happens on resolution (Task 2).
  </action>
  <verify>Start game at rank 1+, pop a group of 4 — capacitor should drop from 100 to ~84</verify>
  <done>Capacitor meter drains when groups are popped, drain amount scales with group size</done>
</task>

<task type="auto">
  <name>Task 2: Change LASER trigger to meter-based</name>
  <files>core/GameEngine.ts</files>
  <action>
In checkComplications():
- Remove the old LASER trigger check (`totalUnitsPopped >= threshold`)
- Add new check: `if (this.state.laserCapacitor <= 0 && rank >= 1)`
- Spawn LASER complication when capacitor hits 0
- Do NOT reset capacitor here — that happens on resolution

In resolveComplication():
- For LASER case: set `this.state.laserCapacitor = 100` (refill to full)
- Remove the old `totalUnitsPopped = 0` reset (no longer needed)

Remove the `complicationThresholds.laser` usage and randomThreshold regeneration for LASER.
(Keep it for now if other complications still use it, but LASER should ignore it.)
  </action>
  <verify>Start game at rank 1+, pop groups until capacitor hits 0 — LASER complication triggers. Fix minigame — capacitor refills to 100.</verify>
  <done>LASER triggers at capacitor=0, resolves by refilling to 100</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:run` passes all tests
- [ ] Capacitor drains when popping groups (visual meter decreases)
- [ ] LASER triggers when capacitor reaches 0
- [ ] Completing LASER minigame refills capacitor to 100
- [ ] LASER does NOT trigger if rank < 1
</verification>

<success_criteria>
- All tasks completed
- Capacitor drain per unit is ~4 (tunable)
- LASER triggers at 0, not at random threshold
- Resolution refills capacitor
- No TypeScript errors
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-hud-balance/05-02-SUMMARY.md`
</output>
