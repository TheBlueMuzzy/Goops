---
phase: 09-art-decomposition
plan: 01
type: execute
---

<objective>
Extract minigame state management into dedicated hooks with TypeScript types.

Purpose: Isolate the three minigame state machines (LASER, LIGHTS, CONTROLS) from the rendering code, making them testable and reusable.
Output: Three custom hooks (useLaserMinigame, useLightsMinigame, useControlsMinigame) and shared types in a minigame types file.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-quick-wins/08-01-SUMMARY.md

**Key files:**
@components/Art.tsx (source file to extract from)
@types.ts (existing types)

**Tech available:** React hooks, TypeScript
**Established patterns:**
- Module-level constants (from Phase 8)
- Pure utility functions
- Hooks in hooks/ directory

**Constraining decisions:**
- All 81 tests must pass throughout refactor
- No gameplay changes - purely structural

**Art.tsx structure (1,478 lines):**
- Lines 183-236: Minigame state interfaces and initialization
- Lines 246-311: useEffect for minigame initialization/reset
- Lines 553-581: LASER slider handling (updateLaserSlider)
- Lines 585-636: LIGHTS sequence generation and showing
- Lines 639-698: LIGHTS button and slider helpers
- Lines 701-778: LIGHTS button/slider handlers
- Lines 781-899: Text state helpers (getLaserTextState, getLightsTextState, getControlsTextState)
- Lines 812-900: CONTROLS corner lights and dial alignment
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create minigame types file</name>
  <files>types/minigames.ts</files>
  <action>
Create a new types file for minigame-related interfaces:

1. Move from Art.tsx:
   - LaserComplication interface (lines 183-187)
   - LightsPhase type (line 199)
   - LightsComplication interface (lines 200-206)
   - ControlsComplication interface (lines 220-225)

2. Add new types:
   - LaserMinigameState (extends LaserComplication, adds sliders: (-1|0|1)[])
   - LightsMinigameState (extends LightsComplication, adds slider: -1|0|1)
   - ControlsMinigameState (extends ControlsComplication, adds localDialRotation, isDialDragging)

3. Export all types

Keep the original types in Art.tsx temporarily (will be removed in Plan 3) to avoid breaking the build mid-refactor.
  </action>
  <verify>npm run test:run passes, TypeScript compiles without errors</verify>
  <done>types/minigames.ts exists with all minigame interfaces exported, build passes</done>
</task>

<task type="auto">
  <name>Task 2: Extract useLaserMinigame hook</name>
  <files>hooks/useLaserMinigame.ts</files>
  <action>
Create hook that encapsulates LASER minigame state machine:

1. State:
   - laserComplication: LaserComplication (active, solved, targets)
   - laserSliders: (-1|0|1)[]
   - shakingSlider: number | null

2. Extract functions from Art.tsx:
   - Initialization logic (lines 263-285): generate random targets when complication activates
   - Reset logic (lines 248-252): reset when complication removed
   - updateLaserSlider (lines 553-581): handle slider changes, check for solve
   - getLaserLightColors (lines 903-920): get indicator light colors
   - getLaserTextState (lines 781-795): get "RESET LASER" / "FIXED" text state

3. Parameters:
   - complications: Complication[] (from GameState)
   - isLaserMaxed: boolean (for max-level effect)
   - onResolveComplication: (id: string) => void

4. Return:
   - laserSliders, updateLaserSlider
   - shakingSlider
   - getLaserLightColors, getLaserTextState

Import types from types/minigames.ts. Do NOT modify Art.tsx yet - that's Plan 3.
  </action>
  <verify>npm run test:run passes, hook file compiles, exports correct interface</verify>
  <done>hooks/useLaserMinigame.ts exists with complete LASER state machine, all tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Extract useLightsMinigame hook</name>
  <files>hooks/useLightsMinigame.ts</files>
  <action>
Create hook that encapsulates LIGHTS minigame state machine:

1. State:
   - lightsComplication: LightsComplication (phase, slider1Target, sequence, inputIndex, showingIndex)
   - lightSlider: -1|0|1
   - lightsSliderShaking: boolean

2. Extract functions from Art.tsx:
   - Initialization logic (lines 287-298): generate sequence when complication activates
   - Reset logic (lines 253-257): reset when complication removed
   - generateLightsSequence (lines 585-603): create 3-4 button sequence
   - startShowingSequence (lines 606-636): animate sequence display with timeouts
   - handleLightsButton (lines 701-738): process button input during input phase
   - handleLightsSliderChange (lines 740-778): process slider input
   - getLightsButtonLightColor (lines 648-669): get button indicator colors
   - getLightsSliderLightColors (lines 672-698): get slider indicator colors
   - getLightsTextState (lines 796-810): get "RESET LIGHTS" / "FIXED" text state
   - BUTTON_COLORS constant (lines 639-643)

3. Parameters:
   - complications: Complication[]
   - isLightsMaxed: boolean
   - pressedBtn: string | null (for button light feedback)
   - onResolveComplication: (id: string) => void

4. Return:
   - lightsComplication, lightSlider
   - handleLightsButton, handleLightsSliderChange
   - lightsSliderShaking
   - getLightsButtonLightColor, getLightsSliderLightColors, getLightsTextState

Import types from types/minigames.ts. Do NOT modify Art.tsx yet.
  </action>
  <verify>npm run test:run passes, hook file compiles, exports correct interface</verify>
  <done>hooks/useLightsMinigame.ts exists with complete LIGHTS state machine, all tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:run` passes all 81 tests
- [ ] TypeScript compiles without errors
- [ ] types/minigames.ts has all interfaces
- [ ] hooks/useLaserMinigame.ts exports complete API
- [ ] hooks/useLightsMinigame.ts exports complete API
- [ ] Art.tsx unchanged (hooks not integrated yet)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Hooks are self-contained with no side effects on existing code
</success_criteria>

<output>
After completion, create `.planning/phases/09-art-decomposition/09-01-SUMMARY.md`
</output>
