# Phase 27.1: Physics-Controlled Active Piece - Research

**Researched:** 2026-02-05
**Domain:** Verlet soft-body physics integration with falling-block puzzle game mechanics
**Confidence:** HIGH

<research_summary>
## Summary

Researched how to transfer falling piece motion from GameEngine to SoftBodyPhysics. The current architecture has GameEngine update grid position, then syncs blob target position, causing a timing mismatch that produces flickering.

The proven solution is the **Proto-9 pattern**: physics owns the falling motion directly via `visualOffsetY`. Instead of syncing blob position TO game state, the physics simulation IS the source of truth for visual position. Grid state only commits when the piece locks.

**Primary recommendation:** Port Proto-9's `visualOffsetY` pattern to active pieces. Physics drives smooth falling with collision detection against locked goop. GameEngine becomes the consumer of physics state (for lock detection, scoring) rather than the driver.

</research_summary>

<standard_stack>
## Standard Stack

### Core (Already In Project)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Verlet physics | Custom | Soft-body simulation | Already ported from prototypes |
| useSoftBodyPhysics | Custom | React hook interface | Already integrated |
| blobFactory | Custom | Grid-to-pixel conversion | Already handles coordinates |

### Architecture Pattern
| Pattern | Purpose | Status |
|---------|---------|--------|
| visualOffsetY | Smooth sub-cell falling motion | Proven in Proto-9 |
| Grid collision | Check cells below for obstacles | Proven in Proto-9 |
| Deferred lock | Queue lock action to end-of-frame | Proven in Proto-9 |
| Two-tier authority | Grid = truth, Physics = visual | Industry standard |

### No External Dependencies Needed
This phase uses existing code. No npm packages required.

</standard_stack>

<architecture_patterns>
## Architecture Patterns

### Recommended: Two-Layer Architecture

```
┌─────────────────────────────────────────────────┐
│           AUTHORITATIVE LAYER                    │
│  GameEngine grid state (discrete cells)          │
│  - Determines collisions, clears, scoring        │
│  - Updated when piece LOCKS (not during fall)    │
└─────────────────────────────────────────────────┘
                      ▲
                      │ Lock event (once per piece)
                      │
┌─────────────────────────────────────────────────┐
│           VISUAL/PHYSICS LAYER                   │
│  SoftBodyPhysics (continuous motion)             │
│  - Owns falling motion (visualOffsetY)           │
│  - Drives smooth animation every frame           │
│  - Detects collision via grid read-only lookup   │
└─────────────────────────────────────────────────┘
```

### Pattern 1: visualOffsetY Falling
**What:** Sub-cell offset that accumulates during falling, resets on grid cell transition
**When to use:** Any smooth falling motion that needs to track grid position
**Example:**
```typescript
// From Proto-9 (lines 1598-1609)
const fallAmount = fallSpeed * dt;
fallingBlob.visualOffsetY += fallAmount;

// Move grid cells when offset exceeds cell size
while (fallingBlob.visualOffsetY >= CELL_SIZE) {
  for (const cell of fallingBlob.gridCells) {
    cell.y += 1;
  }
  fallingBlob.visualOffsetY -= CELL_SIZE;
}

// Update physics target (this drives visual position)
const gridCentroid = getGridCentroid(fallingBlob.gridCells);
fallingBlob.targetY = gridCentroid.y + fallingBlob.visualOffsetY;
```

### Pattern 2: Grid-Based Collision Detection
**What:** Check if cells below are occupied by different blob or floor
**When to use:** Determining when piece can't fall further
**Example:**
```typescript
// From Proto-9 (lines 1617-1629)
let canFallMore = true;
for (const cell of fallingBlob.gridCells) {
  const nextY = cell.y + 1;
  if (nextY >= GRID_ROWS) {
    canFallMore = false;
    break;
  }
  const targetCell = grid[nextY]?.[cell.x];
  if (targetCell && targetCell.blobId !== fallingBlob.id) {
    canFallMore = false;
    break;
  }
}
```

### Pattern 3: Deferred Lock Action
**What:** Queue lock for end-of-frame rather than mutating mid-loop
**When to use:** When lock causes state changes that affect other operations
**Example:**
```typescript
// Flag for lock (Proto-9 line 1633)
if (!canFallMore && fallingBlob.visualOffsetY < 0.1) {
  needsLockRef.current = true;
}

// At end of physics step (Proto-9 line 1715-1718)
if (needsLockRef.current) {
  lockActivePiece();
  needsLockRef.current = false;
}
```

### Anti-Patterns to Avoid
- **Double-update loop:** GameEngine updates position → Physics reads it → Rendering sees stale data. This is the CURRENT bug.
- **Physics follows game state:** Creates timing mismatch. Physics should LEAD, game state should FOLLOW.
- **Timer-only lock detection:** Proto-9 uses collision + position threshold. More responsive than timers.

</architecture_patterns>

<dont_hand_roll>
## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Smooth falling | Custom lerp/interpolation | visualOffsetY + Verlet | Proto-9 pattern is proven, handles wobble naturally |
| Collision detection | Raycasting or physics queries | Grid cell lookup | Grid is source of truth, O(1) lookup |
| Lock timing | Complex state machines | canFallMore + visualOffsetY threshold | Simple and responsive |
| Frame timing | Variable dt physics | Fixed timestep accumulator | Industry standard, prevents instability |

**Key insight:** Proto-9 already solved all these problems. The entire falling system can be ported with minimal modification. Don't reinvent—extract and integrate.

</dont_hand_roll>

<common_pitfalls>
## Common Pitfalls

### Pitfall 1: Double-Update Timing Mismatch (CURRENT BUG)
**What goes wrong:** Flickering between game state position and physics position
**Why it happens:** GameEngine updates grid position, sync updates blob target, physics updates blob position. Three sources of truth → timing gaps.
**How to avoid:** Physics OWNS falling motion. GameEngine only reads position at lock time.
**Warning signs:** Flickering, position jumps, visual desync from expected position

### Pitfall 2: Spiral of Death
**What goes wrong:** Physics takes longer than real-time, frame budget explodes
**Why it happens:** Accumulator grows unboundedly when physics step exceeds frame time
**How to avoid:** Cap maximum physics steps per frame (e.g., max 4 steps)
**Warning signs:** Sudden slowdowns, physics "catching up" visibly, dropped frames

### Pitfall 3: Lock Happening Too Early
**What goes wrong:** Piece locks before visually reaching rest position
**Why it happens:** Collision detected when visualOffsetY still has sub-cell offset
**How to avoid:** Require `visualOffsetY < 0.1` threshold before lock (Proto-9 pattern)
**Warning signs:** Pieces appearing to "pop" into place, gap between piece and stack

### Pitfall 4: Grace Period Feel
**What goes wrong:** Game feels unforgiving—no time to adjust after landing
**Why it happens:** Proto-9 has NO grace period (immediate lock)
**How to avoid:** Keep GameEngine's existing lock delay (500ms), triggered when physics reports collision
**Warning signs:** User complaints about not being able to adjust after landing

### Pitfall 5: Fast-Fall Breaking Physics
**What goes wrong:** Fast-fall causes tunneling or position jumps
**Why it happens:** Large dt or velocity injection skips collision checks
**How to avoid:** Multiply gravity (not inject velocity), cap maximum fall per frame
**Warning signs:** Pieces passing through obstacles, ending up below floor

</common_pitfalls>

<code_examples>
## Code Examples

### Active Piece Physics Step (Proto-9 Pattern)
```typescript
// Source: Proto-9 lines 1598-1635, adapted for Goops
function stepActivePieceFalling(blob: SoftBlob, dt: number, grid: Grid) {
  // Calculate fall amount
  const baseSpeed = isFastDropping ? FALL_SPEED * FAST_DROP_FACTOR : FALL_SPEED;
  const fallAmount = baseSpeed * dt;

  // Check if can fall more BEFORE moving
  let canFallMore = true;
  for (const cell of blob.gridCells) {
    const nextY = cell.y + 1;
    if (nextY >= GRID_ROWS || (grid[nextY]?.[cell.x] && grid[nextY][cell.x].blobId !== blob.id)) {
      canFallMore = false;
      break;
    }
  }

  if (canFallMore) {
    // Accumulate visual offset
    blob.visualOffsetY += fallAmount;

    // Move grid cells when offset exceeds cell size
    while (blob.visualOffsetY >= CELL_SIZE) {
      for (const cell of blob.gridCells) {
        cell.y += 1;
      }
      blob.visualOffsetY -= CELL_SIZE;
    }
  }

  // Update physics target position
  const gridCentroid = getGridCentroid(blob.gridCells);
  blob.targetY = gridCentroid.y + blob.visualOffsetY;

  // Landing check
  if (!canFallMore && blob.visualOffsetY < 0.1) {
    return { shouldLock: true };
  }

  return { shouldLock: false };
}
```

### Integration Point: GameEngine Lock Handler
```typescript
// Source: Goops current pattern, adapted for physics-driven falling
// GameEngine stops driving position, starts listening for lock signal

function tickActivePiece(dt: number) {
  const activePieceBlob = softBodyPhysics.getActivePieceBlob();
  if (!activePieceBlob) return;

  // Physics drives falling - just check for lock signal
  if (activePieceBlob.shouldLock && !this.lockTimerStarted) {
    this.startLockTimer();  // Existing grace period logic
  }

  // When lock timer expires, commit physics position to game state
  if (this.lockTimerExpired) {
    const finalCells = activePieceBlob.gridCells;
    this.commitPieceToGrid(finalCells);  // Existing lock logic
    softBodyPhysics.lockActivePiece();   // Tell physics to convert to locked blob
  }
}
```

### Fast-Fall: Gravity Boost (Not Velocity Injection)
```typescript
// Source: Industry pattern, NOT Proto-9 (which has no fast-fall button)
// Fast-fall multiplies gravity, doesn't inject velocity

const FALL_SPEED = 200;        // pixels/second (normal)
const FAST_DROP_FACTOR = 8;    // 8x multiplier (matches existing Goops behavior)

const effectiveSpeed = isFastDropping
  ? FALL_SPEED * FAST_DROP_FACTOR
  : FALL_SPEED;
```

</code_examples>

<player_mechanics>
## Player Mechanics to Preserve

These mechanics currently live in GameEngine and must continue working when physics takes over falling.

### Rotation (Q/E Keys, Screen Taps)

**Current Implementation:** `core/commands/actions.ts` - `RotateGoopCommand`

**What happens on rotate:**
1. Rotation state changes (0 → 1 → 2 → 3, modulo 4)
2. Piece cells are rotated: `({ x, y }) => ({ x: -y, y: x })` (90° CCW matrix)
3. Cells normalized to positive coordinates
4. Lock timer resets (if active)
5. `lockResetCount++` (toward 10-reset limit)

**Proto-8/9 Pattern (portable):**
```typescript
// Rotation math (Proto-9 line 750)
function rotatePoint(x: number, y: number, angleDeg: number): Vec2 {
  const rad = (angleDeg * Math.PI) / 180;
  return { x: x * Math.cos(rad) - y * Math.sin(rad),
           y: x * Math.sin(rad) + y * Math.cos(rad) };
}

// Grid cell rotation (Proto-9 lines 2110-2120)
const rotateShape = (cells: Vec2[], times: number): Vec2[] => {
  let result = cells.map(c => ({ ...c }));
  for (let i = 0; i < (times % 4); i++) {
    result = result.map(({ x, y }) => ({ x: -y, y: x }));  // 90° CCW
  }
  // Normalize to positive coordinates
  const minX = Math.min(...result.map(c => c.x));
  const minY = Math.min(...result.map(c => c.y));
  return result.map(c => ({ x: c.x - minX, y: c.y - minY }));
};
```

**Integration approach:**
- Keep rotation command in GameEngine (affects `blob.gridCells`)
- Physics recomputes `targetX/Y` from new grid centroid
- No dynamic tumble physics needed — rotation is instant grid snap
- Proto-8/9 has NO wall kicks or blocked rotation — same as current Goops

---

### Lock Delay / Grace Period

**Current Implementation:** `core/GameEngine.ts` lines 34, 1206-1216

**Constants:**
| Value | Normal | Fast-Drop |
|-------|--------|-----------|
| Lock delay | 500ms | 50ms |
| Reset limit | 10 moves | 10 moves |

**Trigger:** Lock timer starts on first frame piece collides with obstacle

**Reset triggers:**
- Board rotation (SpinTankCommand) → resets timer, increments counter
- Piece rotation (RotateGoopCommand) → resets timer, increments counter
- Piece swap → resets timer (counter NOT incremented)

**Force lock:** Either timer expires OR 10 resets reached

**Integration approach:**
- Physics reports `canFallMore = false` when collision detected
- GameEngine starts lock timer when physics reports collision
- Timer/reset logic stays in GameEngine (proven feel)
- On timer expiry: GameEngine calls `lockActivePiece()`, physics converts blob to locked

---

### Piece Swap (Hold)

**Current Implementation:** `core/commands/actions.ts` lines 200-245

**What happens on swap:**
1. Check if stored piece fits at current position (collision test)
2. If collision → reject swap, emit `ACTION_REJECTED`
3. If fits → exchange pieces:
   - Current piece → stored
   - Stored piece → active (or spawn new if first swap)
4. Position preserved: `x`, `y`, `screenX`
5. Rotation reset to 0
6. Lock timer cleared (fresh grace period)

**No cooldown:** Player can swap unlimited times (if piece fits)

**Integration approach:**
- Swap command removes current physics blob
- Creates new blob for swapped-in piece at same position
- Position comes from physics blob's current `gridCells` (not GameEngine's stale state)
- Lock timer reset handled by GameEngine (existing logic)

---

### Fast-Fall (S Key, Vertical Drag)

**Current Implementation:**
- Input: `Game.tsx` lines 239, 251-253 (keyboard), `useInputHandlers.ts` lines 237-239 (touch)
- State: `GameEngine.isFastDropping` (boolean)
- Speed: `FAST_DROP_FACTOR = 8` (8x faster)

**Triggers:**
| Input | Start | Stop |
|-------|-------|------|
| Keyboard | S keydown | S keyup |
| Touch drag | Vertical drag down (dy > 10px) | Drag stops or pointer up |
| Swipe | Quick downward swipe | Auto-stops after 150ms |

**Effects:**
- Fall speed: 8x faster (780ms → 97.5ms per block)
- Lock delay: 500ms → 50ms
- LIGHTS complication: Triggers brightness recovery

**Integration approach:**
- `isFastDropping` state stays in GameEngine
- Physics reads `isFastDropping` to determine fall speed
- Fall speed formula: `baseSpeed * (isFastDropping ? 8 : 1)`
- Must cap max fall per frame to prevent tunneling through obstacles

**Potential issue:** At 8x speed with physics wobble, piece might feel too bouncy. May need to increase damping during fast-fall or reduce wobble amplitude.

</player_mechanics>

<sota_updates>
## State of the Art (2024-2026)

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Game state drives visuals | Physics drives visuals, game state follows | Always best practice | Eliminates timing mismatch |
| Timer-only lock delay | Collision + position threshold + timer | Modern Tetris variants | More responsive feel |
| Variable timestep physics | Fixed timestep with accumulator | Always best practice | Stable simulation |

**Patterns from modern falling-block games:**
- **Tetris Effect (2018+):** Visual layer interpolates between authoritative states
- **Puyo Puyo Tetris 2:** Lock delay with move reset (limited resets)
- **Not Tetris 2:** Physics owns falling, grid commits when stable (>80% cell coverage rule)

**Key insight from research:** The industry standard is "grid leads, physics follows" for LOCKED pieces. But for FALLING pieces, "physics leads, grid follows" (commit on lock). Our current bug is that we have it backwards during falling.

</sota_updates>

<open_questions>
## Open Questions

### Resolved (from additional research)

1. **Grace period implementation** ✓ RESOLVED
   - Physics reports `canFallMore = false` on collision
   - GameEngine owns lock timer (500ms normal, 50ms fast-drop)
   - Reset on rotation/board spin (up to 10 resets)
   - Existing logic preserved, just triggered by physics state

2. **Rotation during fall** ✓ RESOLVED
   - Rotation is instant grid snap (same as current)
   - Updates `blob.gridCells` with rotated offsets
   - Physics recomputes centroid → new `targetX/Y`
   - No wall kicks (matches current behavior)
   - Proto-8/9 rotation math is directly portable

3. **Piece swap interaction** ✓ RESOLVED
   - Swap removes current physics blob
   - Creates new blob for swapped piece at same position
   - Position comes from physics blob's `gridCells`
   - Lock timer resets (existing behavior)

### Still Open

1. **Fast-fall physics feel**
   - What we know: 8x speed multiplier, works with current non-physics falling
   - What's unclear: Will 8x feel right with soft-body wobble? Might feel too bouncy.
   - Recommendation: Start with 8x, tune damping during fast-fall if needed
   - Fallback: Increase damping or reduce homeStiffness during fast-drop

2. **Tunneling prevention at high speed**
   - What we know: 8x speed = ~97.5ms per cell, could skip collision checks
   - What's unclear: Is current collision check granular enough?
   - Recommendation: Cap max fall per physics step (e.g., 0.5 cells max), run multiple steps if needed

3. **Physics-GameEngine communication pattern**
   - What we know: Physics needs to report collision state to GameEngine
   - What's unclear: Callback? Polling? Shared state?
   - Options:
     a. Physics blob has `isColliding` property, GameEngine reads it
     b. Physics emits event on collision start
     c. GameEngine queries `softBodyPhysics.isActivePieceColliding()`
   - Recommendation: Option (a) is simplest — blob property, polled each tick

</open_questions>

<sources>
## Sources

### Primary (HIGH confidence)
- `prototypes/SoftBodyProto9.tsx` — Falling system (lines 1598-1700), rotation (lines 750, 2110-2120)
- `prototypes/SoftBodyProto8.tsx` — Rotation mechanics, boundary constraints
- `core/softBody/physics.ts` — Verlet engine implementation
- `core/GameEngine.ts` — Falling logic (1186-1265), lock delay (34, 1206-1216), fast-drop (33, 1194-1196)
- `core/commands/actions.ts` — Rotation (138-142), swap (200-245), tank spin (57-61), fast-drop (151-158)
- `Game.tsx` — Keyboard input (239, 251-253)
- `hooks/useInputHandlers.ts` — Touch input, drag handling, swipe detection

### Secondary (MEDIUM confidence)
- Tetris Wiki (Lock delay, Drop mechanics) — Industry patterns verified
- Gaffer on Games (Fix Your Timestep) — Fixed timestep accumulator pattern
- Game Programming Patterns (Game Loop) — Two-layer architecture

### Tertiary (LOW confidence - needs validation)
- Not Tetris 2 approach (>80% coverage rule) — Different game, may not apply
- Cowboy Programming blob physics — General soft-body, not puzzle-specific

</sources>

<metadata>
## Metadata

**Research scope:**
- Core technology: Verlet soft-body physics (already in project)
- Ecosystem: Proto-8/9 patterns, industry standards for falling-block games
- Patterns: visualOffsetY, grid collision, deferred lock, two-layer architecture
- Player mechanics: Rotation, lock delay, piece swap, fast-fall
- Pitfalls: Double-update timing, lock threshold, fast-fall tunneling

**Confidence breakdown:**
- Standard stack: HIGH - Already implemented in project
- Architecture: HIGH - Proto-9 is working code, industry patterns verified
- Pitfalls: HIGH - Current bug is documented, Proto-9 avoids it
- Code examples: HIGH - Directly from Proto-8/9 source
- Player mechanics: HIGH - Full audit of GameEngine and commands

**Research date:** 2026-02-05
**Valid until:** 2026-03-05 (30 days - internal code, stable patterns)

</metadata>

---

*Phase: 27.1-physics-controlled-active-piece*
*Research completed: 2026-02-05*
*Ready for planning: yes*
