---
phase: 27.1-physics-controlled-active-piece
plan: 02
type: execute
---

<objective>
Integrate physics-controlled falling with GameEngine's lock timer system.

Purpose: GameEngine stops driving falling motion and instead reads collision state from physics to manage lock timer.
Output: GameEngine and physics work together - physics owns falling, GameEngine owns lock timing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27.1-physics-controlled-active-piece/27.1-RESEARCH.md
@.planning/phases/27.1-physics-controlled-active-piece/27.1-01-SUMMARY.md (will exist after Plan 01)

**Key source files:**
@core/GameEngine.ts (lines 1186-1265 for current tickActivePiece)
@hooks/useSoftBodyPhysics.ts
@components/GameBoard.tsx (blob lifecycle hooks from 27-01)

**From RESEARCH.md - Lock delay mechanics:**
- Normal: 500ms, Fast-drop: 50ms
- Reset triggers: rotation, board spin, swap
- Force lock at 10 resets
- Physics reports collision, GameEngine manages timer

**From RESEARCH.md - Integration pattern:**
- Physics blob has `isColliding` property
- GameEngine polls it each tick
- GameEngine starts lock timer when `isColliding` becomes true
- On lock: GameEngine commits cells to grid, tells physics to remove/convert blob
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add physics stepping for active blob in useSoftBodyPhysics</name>
  <files>hooks/useSoftBodyPhysics.ts</files>
  <action>
Update the physics hook to call `stepActivePieceFalling` for the active piece blob.

1. Import `stepActivePieceFalling` from physics.ts

2. Add method to get active piece blob:
```typescript
const getActivePieceBlob = useCallback(() => {
  return blobsRef.current.find(b => b.id.startsWith('active-'));
}, []);
```

3. Modify the `step` function to accept parameters for active piece falling:
```typescript
const step = useCallback((
  dt: number,
  grid?: TankCell[][],
  gridRows?: number,
  fallSpeed?: number
) => {
  // Existing physics stepping...

  // Step active piece falling if we have grid info
  if (grid && gridRows !== undefined && fallSpeed !== undefined) {
    const activeBlob = blobsRef.current.find(b => b.id.startsWith('active-'));
    if (activeBlob && !activeBlob.isLocked) {
      stepActivePieceFalling(activeBlob, dt, fallSpeed, grid, gridRows);
    }
  }

  // Continue with existing Verlet physics...
}, []);
```

4. Export `getActivePieceBlob` from the hook's return value.

The grid and fallSpeed are passed in from GameBoard/GameEngine because:
- Grid state lives in GameEngine
- fallSpeed depends on `isFastDropping` which GameEngine owns
- This keeps physics decoupled from game state
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>useSoftBodyPhysics.step() accepts grid/fallSpeed and calls stepActivePieceFalling, getActivePieceBlob() exported</done>
</task>

<task type="auto">
  <name>Task 2: Refactor GameEngine.tickActivePiece to read physics state</name>
  <files>core/GameEngine.ts</files>
  <action>
Refactor `tickActivePiece` to stop driving position and instead read collision state from physics.

**Current flow (to remove):**
- GameEngine calculates gravity
- GameEngine moves piece Y position
- GameEngine checks collision
- GameEngine manages lock timer

**New flow:**
- Physics drives falling (done in Plan 01)
- GameEngine reads `isColliding` from physics blob
- GameEngine manages lock timer based on that signal
- Lock mechanics stay the same (500ms/50ms, 10 reset limit)

Changes to `tickActivePiece`:

1. Add parameter to receive physics collision state:
```typescript
tickActivePiece(dt: number, physicsIsColliding: boolean | null): void {
```

2. Remove the gravity/position update code (lines ~1194-1205) - physics handles this now

3. Replace collision detection with physics state:
```typescript
// OLD: const collision = checkCollision(...)
// NEW: Use physics collision state
if (physicsIsColliding === null) return;  // No physics blob yet

if (physicsIsColliding) {
  // Start lock timer (existing logic)
  if (this.lockStartTime === null) {
    this.lockStartTime = Date.now();
  }
  // ... rest of lock timer logic unchanged
}
```

4. Keep ALL existing lock timer logic:
- `LOCK_DELAY_MS = 500`
- `effectiveLockDelay = this.isFastDropping ? 50 : LOCK_DELAY_MS`
- `lockResetCount >= 10` force lock
- `lockActivePiece()` call on timer expiry

5. Add a `syncActivePieceFromPhysics` method to read position from physics blob when needed:
```typescript
syncActivePieceFromPhysics(gridCells: Vec2[]): void {
  if (!this.state.activeGoop) return;
  // Physics gridCells become the source of truth for piece position
  // This is called when we need to commit (on lock)
  this.state.activeGoop.cells = gridCells.map(c => ({ x: c.x, y: c.y }));
  // Update y to match physics (for lock position)
  const minY = Math.min(...gridCells.map(c => c.y));
  this.state.activeGoop.y = minY;
}
```

Do NOT change the rest of `lockActivePiece()` - it still commits cells to grid, handles wild pieces, etc.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>tickActivePiece accepts physicsIsColliding, removes gravity code, uses physics state for lock detection</done>
</task>

<task type="auto">
  <name>Task 3: Wire up GameBoard to pass physics state to GameEngine</name>
  <files>components/GameBoard.tsx</files>
  <action>
Update GameBoard to:
1. Pass grid and fallSpeed to physics step
2. Read collision state from physics blob
3. Pass collision state to GameEngine tick

In the game loop (useEffect with requestAnimationFrame):

```typescript
// Calculate fall speed based on game state
const baseFallSpeed = 200;  // pixels/second (matches Proto-9)
const FAST_DROP_FACTOR = 8;
const fallSpeed = engineRef.current?.isFastDropping
  ? baseFallSpeed * FAST_DROP_FACTOR
  : baseFallSpeed;

// Step physics with grid info
softBodyPhysics.step(
  dt,
  engineRef.current?.state.grid,
  GRID_ROWS,  // from constants
  fallSpeed
);

// Get collision state from physics
const activeBlob = softBodyPhysics.getActivePieceBlob();
const physicsIsColliding = activeBlob?.isColliding ?? null;

// Pass to GameEngine
engineRef.current?.tickActivePiece(dt, physicsIsColliding);
```

Also update the existing blob sync useEffect (from 27-01) to NOT update blob target position - physics now owns that. The sync useEffect should only:
- Create blob on spawn (keep)
- Remove blob on lock (keep)
- Do NOT update targetX/Y every frame (remove - physics does this now)

Find the position sync useEffect and either:
- Remove it entirely, OR
- Change it to only sync rotation (update gridCells when piece rotates)

For now, remove the position sync. Rotation sync will be added in Plan 03.
  </action>
  <verify>`npm run test:run` passes, `npm run dev` starts without errors</verify>
  <done>GameBoard passes grid/fallSpeed to physics, reads collision state, passes to GameEngine, removed position sync</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run test:run` passes
- [ ] Physics step receives grid and fallSpeed
- [ ] GameEngine tickActivePiece uses physics collision state
- [ ] Lock timer logic unchanged (500ms/50ms, 10 resets)
- [ ] Position sync useEffect removed from GameBoard
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Physics drives falling motion
- GameEngine manages lock timing from physics collision signal
- No flickering (physics is single source of truth for position)
</success_criteria>

<output>
After completion, create `.planning/phases/27.1-physics-controlled-active-piece/27.1-02-SUMMARY.md`
</output>
