---
phase: 27.1-physics-controlled-active-piece
plan: 03
type: execute
---

<objective>
Integrate player mechanics (rotation, fast-fall, swap) with physics-controlled falling.

Purpose: All existing player controls work seamlessly with the new physics-driven falling system.
Output: Rotation updates physics blob, fast-fall affects physics speed, swap replaces physics blob.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27.1-physics-controlled-active-piece/27.1-RESEARCH.md
@.planning/phases/27.1-physics-controlled-active-piece/27.1-01-SUMMARY.md
@.planning/phases/27.1-physics-controlled-active-piece/27.1-02-SUMMARY.md

**Key source files:**
@core/commands/actions.ts (RotateGoopCommand, SwapPieceCommand)
@hooks/useSoftBodyPhysics.ts

**From RESEARCH.md - Player mechanics:**

**Rotation:**
- Rotation is instant grid snap (not dynamic tumble)
- Updates blob.gridCells with rotated offsets
- Physics recomputes centroid → new targetX/Y
- Lock timer resets on successful rotation (existing behavior)

**Fast-fall:**
- GameEngine.isFastDropping already passed to physics via fallSpeed (Plan 02)
- No additional work needed here

**Swap:**
- Swap removes current physics blob
- Creates new blob for swapped piece at same position
- Position comes from physics blob's gridCells
- Lock timer resets (existing behavior)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add updateBlobGridCells method to physics hook</name>
  <files>hooks/useSoftBodyPhysics.ts</files>
  <action>
Add a method to update an active blob's gridCells (for rotation):

```typescript
const updateBlobGridCells = useCallback((blobId: string, newGridCells: Vec2[]) => {
  const blob = blobsRef.current.find(b => b.id === blobId);
  if (!blob) return;

  // Update grid cells
  blob.gridCells = newGridCells.map(c => ({ x: c.x, y: c.y }));

  // Recompute target position from new centroid
  let sumX = 0, sumY = 0;
  for (const cell of blob.gridCells) {
    sumX += cell.x;
    sumY += cell.y;
  }
  const centroidX = sumX / blob.gridCells.length;
  const centroidY = sumY / blob.gridCells.length;

  const CELL_SIZE = 30;
  const PHYSICS_GRID_OFFSET_X = -180;
  const PHYSICS_GRID_OFFSET_Y = 0;
  blob.targetX = PHYSICS_GRID_OFFSET_X + (centroidX + 0.5) * CELL_SIZE;
  blob.targetY = PHYSICS_GRID_OFFSET_Y + (centroidY + 0.5) * CELL_SIZE + blob.visualOffsetY;

  // Also update home positions for vertices to match new shape
  // This prevents the blob from trying to return to old shape
  updateBlobHomePositions(blob);
}, []);

// Helper to recalculate home positions after rotation
function updateBlobHomePositions(blob: SoftBlob) {
  // Recalculate vertex home offsets from new centroid
  const centroidX = blob.targetX;
  const centroidY = blob.targetY - blob.visualOffsetY;

  for (const vertex of blob.vertices) {
    vertex.homeOffset = {
      x: vertex.pos.x - centroidX,
      y: vertex.pos.y - centroidY
    };
  }
}
```

Export `updateBlobGridCells` from the hook's return value.

This allows rotation to update the blob's shape without recreating the entire blob.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>updateBlobGridCells method exists and exported, updates gridCells and recomputes target/home positions</done>
</task>

<task type="auto">
  <name>Task 2: Wire rotation command to update physics blob</name>
  <files>components/GameBoard.tsx</files>
  <action>
Add an effect that syncs rotation to physics blob when piece rotates.

The RotateGoopCommand already updates `activeGoop.cells` and `activeGoop.rotation`. We need to sync this to the physics blob.

Add a useEffect that watches rotation changes:

```typescript
// Sync rotation to physics blob
useEffect(() => {
  if (!activeGoop || !softBodyPhysics) return;

  const activeBlob = softBodyPhysics.getActivePieceBlob();
  if (!activeBlob) return;

  // Convert activeGoop.cells to grid cells with current position offset
  const gridCells = activeGoop.cells.map(cell => ({
    x: activeGoop.x + cell.x,
    y: Math.floor(activeGoop.y) + cell.y
  }));

  // Update physics blob
  softBodyPhysics.updateBlobGridCells(activeBlob.id, gridCells);
}, [activeGoop?.rotation, activeGoop?.cells, softBodyPhysics]);
```

Note: We watch `rotation` and `cells` because rotation changes both. The `cells` array contains the rotated shape offsets.

This effect fires AFTER RotateGoopCommand runs, syncing the new shape to physics.

The existing lock timer reset in RotateGoopCommand (`engine.lockStartTime = null`) continues to work since GameEngine still manages lock timing.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Rotation changes sync to physics blob via updateBlobGridCells</done>
</task>

<task type="auto">
  <name>Task 3: Update swap command to replace physics blob</name>
  <files>core/commands/actions.ts, components/GameBoard.tsx</files>
  <action>
The SwapPieceCommand needs to work with physics blobs. Two options:

**Option A (simpler):** Let existing blob lifecycle handle it
- SwapPieceCommand changes activeGoop (existing behavior)
- The blob creation useEffect (from 27-01) watches `spawnTimestamp`
- Swapped piece gets new `spawnTimestamp` → triggers new blob creation
- Old blob gets cleaned up when `activeGoop` changes

Check if this already works naturally. The swap command sets:
```typescript
engine.state.activeGoop = testPiece;  // New piece with new spawnTimestamp
```

If `spawnTimestamp` changes, the blob creation effect should fire.

**If Option A doesn't work, use Option B:**

In GameBoard, add explicit blob replacement on swap:

```typescript
// Watch for piece swap (spawnTimestamp change while game running)
const prevSpawnRef = useRef<number | null>(null);

useEffect(() => {
  if (!activeGoop || !softBodyPhysics) return;

  const currentSpawn = activeGoop.spawnTimestamp;
  const prevSpawn = prevSpawnRef.current;

  if (prevSpawn !== null && prevSpawn !== currentSpawn) {
    // Piece changed (swap or new spawn)
    // Remove old blob
    const oldBlobId = `active-${prevSpawn}`;
    softBodyPhysics.removeBlob(oldBlobId);

    // New blob will be created by existing spawn effect
  }

  prevSpawnRef.current = currentSpawn;
}, [activeGoop?.spawnTimestamp, softBodyPhysics]);
```

Test Option A first. If swap doesn't create new blob properly, implement Option B.

The lock timer reset in SwapPieceCommand (`engine.lockStartTime = null`) continues to work.
  </action>
  <verify>`npm run test:run` passes</verify>
  <done>Piece swap properly replaces physics blob (either via existing lifecycle or explicit handling)</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Physics-controlled active piece with all player mechanics</what-built>
  <how-to-verify>
    1. Run: `npm run dev -- --host`
    2. Open game in browser
    3. Start a game at any rank

    **Test falling:**
    - Piece should fall smoothly (soft-body wobble)
    - NO flickering (this was the original bug)

    **Test rotation:**
    - Press Q or E to rotate
    - Piece should rotate instantly (grid snap)
    - Blob shape should update to match rotated piece
    - On mobile: tap left/right sides of screen to rotate

    **Test fast-fall:**
    - Hold S key (or drag down on mobile)
    - Piece should fall much faster (8x)
    - Should still have soft-body wobble (maybe less due to speed)

    **Test landing:**
    - Let piece land on floor or other goop
    - Should have brief grace period to adjust (rotate/move)
    - After ~500ms (or ~50ms if fast-falling), piece locks
    - Rotating during grace period should reset the timer

    **Test swap:**
    - Press swap key (if configured) or use swap button
    - Current piece should be stored
    - New piece should appear with physics blob
    - Old blob should be gone (no duplicates)

    **Test lock reset limit:**
    - Land a piece, then rotate rapidly 10+ times
    - After 10 rotations, piece should force-lock regardless of timer
  </how-to-verify>
  <resume-signal>Type "approved" if all mechanics work correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run test:run` passes
- [ ] Rotation updates physics blob shape
- [ ] Fast-fall affects physics falling speed
- [ ] Swap replaces physics blob cleanly
- [ ] Human verification passed
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Human verified all player mechanics work
- No flickering during falling
- Grace period and lock timing feel correct
- Phase 27.1 complete - physics owns active piece falling
</success_criteria>

<output>
After completion, create `.planning/phases/27.1-physics-controlled-active-piece/27.1-03-SUMMARY.md`

Include in summary:
- Whether Option A or B was used for swap
- Any tuning done to physics feel
- Any issues encountered and how they were resolved
</output>
