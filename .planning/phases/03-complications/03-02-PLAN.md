---
phase: 03-complications
plan: 02
type: execute
---

<objective>
Implement gameplay effects for each complication type.

Purpose: Make complications feel disruptive - when one triggers, the player immediately notices through impaired gameplay.
Output: Three distinct gameplay effects that make complications urgent to fix.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-complications/03-CONTEXT.md
@.planning/phases/03-complications/03-01-SUMMARY.md (when it exists)

**Key files:**
@core/GameEngine.ts — complications array, game state
@components/GameBoard.tsx — rendering, input handling
@core/commands/actions.ts — rotation commands, pop logic

**From CONTEXT.md - Gameplay effects:**
- **Lights Malfunction**: Screen dims to 0 over 3 seconds
- **Controls Malfunction**: Left/right controls randomly flip every 3 seconds
- **Laser Malfunction**: Goops require +1 extra tap to pop

**Prior decisions:**
- Effects should be disruptive but not game-ending
- Player can push through briefly but will want to fix ASAP
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Lights Malfunction effect (screen dim)</name>
  <files>components/GameBoard.tsx</files>
  <action>
1. Add state/logic to detect if LIGHTS complication is active:
   - Check state.complications for type === ComplicationType.LIGHTS

2. When LIGHTS complication active:
   - Apply a dimming overlay that transitions opacity from 0 to 1 over 3 seconds
   - Use CSS transition or animate in useEffect
   - Overlay should be a semi-transparent black div covering the game board
   - At full dim, game is very hard to see but not completely black (maybe 0.8 opacity max)

3. When LIGHTS complication resolved:
   - Immediately remove the dim overlay (instant, not gradual)

4. The dim effect should only apply during PERISCOPE phase (not console)
  </action>
  <verify>
Manual test:
- Trigger LIGHTS complication (by meeting threshold)
- Watch screen dim over 3 seconds
- Fix minigame → screen instantly returns to normal
Run: `npm run test:run`
  </verify>
  <done>Screen dims gradually when LIGHTS complication active, clears when fixed</done>
</task>

<task type="auto">
  <name>Task 2: Implement Controls Malfunction effect (flipping controls)</name>
  <files>core/GameEngine.ts or components/Game.tsx (wherever rotation input is handled)</files>
  <action>
1. Add state to track if controls are currently flipped:
   - controlsFlipped: boolean in GameEngine or local state
   - lastControlsFlipTime: number to track flip interval

2. When CONTROLS complication active:
   - Every 3 seconds, toggle controlsFlipped state
   - When flipped, left input = right rotation, right input = left rotation
   - This affects both keyboard (A/D) and touch drag direction

3. When CONTROLS complication resolved:
   - Reset controlsFlipped to false
   - Reset flip timer

4. Find where rotation input is processed and apply the flip:
   - If controlsFlipped && CONTROLS complication active: invert direction

Note: The flip should happen at fixed 3-second intervals while complication is active, creating unpredictable controls. Player never knows when the next flip will happen.
  </action>
  <verify>
Manual test:
- Trigger CONTROLS complication
- Observe controls flip every 3 seconds
- Fix minigame → controls return to normal
Run: `npm run test:run`
  </verify>
  <done>Controls randomly flip direction every 3 seconds when CONTROLS complication active</done>
</task>

<task type="auto">
  <name>Task 3: Implement Laser Malfunction effect (+1 tap to pop)</name>
  <files>core/GameEngine.ts or wherever pop logic lives</files>
  <action>
1. Add tap tracking per goop group:
   - When LASER complication active, first tap on a filled goop doesn't pop it
   - Instead, mark the group as "primed" (maybe visual indicator)
   - Second tap actually pops it

2. Track which groups have been tapped:
   - Add pendingPopGroups: Set<string> or similar to track group IDs that got first tap
   - On tap: if group not in set, add to set (first tap); if in set, proceed with pop (second tap)

3. When LASER complication resolved:
   - Clear pendingPopGroups
   - Subsequent taps work normally (one tap to pop)

4. Visual feedback for "primed" state (optional but helpful):
   - When group is tapped but not yet popped, show subtle indicator
   - Could be slight color shift or pulse effect

Note: The +1 tap is cumulative with existing "must be filled" requirement. So: fill → tap 1 (prime) → tap 2 (pop).
  </action>
  <verify>
Manual test:
- Trigger LASER complication
- Tap filled goop → doesn't pop
- Tap same goop again → pops
- Fix minigame → one tap works again
Run: `npm run test:run`
  </verify>
  <done>Goops require 2 taps to pop when LASER complication active</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:run` passes all tests
- [ ] LIGHTS: Screen dims over 3s, clears on fix
- [ ] CONTROLS: Left/right flip every 3s, clears on fix
- [ ] LASER: Requires 2 taps, clears on fix
- [ ] Effects only active during their respective complication
- [ ] Effects don't interfere with each other (can have multiple active)
</verification>

<success_criteria>

- All three gameplay effects implemented and working
- Effects are noticeable and disruptive (creates urgency)
- Effects clear immediately when complication is resolved
- No test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/03-complications/03-02-SUMMARY.md`
</output>
