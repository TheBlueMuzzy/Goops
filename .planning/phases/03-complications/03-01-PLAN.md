---
phase: 03-complications
plan: 01
type: execute
---

<objective>
Add complication types, counter tracking, and threshold-based triggers.

Purpose: Replace the placeholder 5% random complication with the real system - three complication types triggered by specific gameplay actions.
Output: GameState tracks counters, GameEngine triggers complications based on thresholds.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-complications/03-CONTEXT.md

**Key files:**
@types.ts — Current ComplicationType enum (only BLOWN_FUSE), Complication interface, GameState
@core/GameEngine.ts — checkComplications(), spawnComplication(), resolveComplication() methods

**Prior decisions:**
- Phase 2 minigames all working (Reset Laser, Reset Lights, Reset Controls)
- Minigames are self-contained state machines in Art.tsx

**From CONTEXT.md:**
- Three complication types: Lights, Controls, Laser
- Triggers based on gameplay counters (not random)
- Threshold values TBD during balancing (use reasonable defaults)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ComplicationType values and counter tracking</name>
  <files>types.ts</files>
  <action>
1. Replace ComplicationType enum with three real types:
   - LIGHTS (was BLOWN_FUSE - rename)
   - CONTROLS
   - LASER

2. Add counter tracking to GameState interface:
   - totalUnitsAdded: number (cumulative goop units placed)
   - totalUnitsPopped: number (cumulative goop units destroyed)
   - totalRotations: number (cumulative tank rotation steps)

3. Add threshold tracking to GameState:
   - complicationThresholds: { lights: number, controls: number, laser: number }
   - These track when next complication triggers (start at base threshold, increment after each trigger)
  </action>
  <verify>TypeScript compiles with no errors: `npx tsc --noEmit`</verify>
  <done>ComplicationType has LIGHTS/CONTROLS/LASER, GameState has counter and threshold fields</done>
</task>

<task type="auto">
  <name>Task 2: Initialize counters and implement trigger logic</name>
  <files>core/GameEngine.ts</files>
  <action>
1. In constructor and startRun(), initialize new state fields:
   - totalUnitsAdded: 0
   - totalUnitsPopped: 0
   - totalRotations: 0
   - complicationThresholds: { lights: 20, controls: 30, laser: 15 } (reasonable starting defaults)

2. Add counter increment points:
   - totalUnitsAdded: increment in mergePiece flow (when piece locks)
   - totalUnitsPopped: increment when goop is popped (in existing pop logic)
   - totalRotations: increment when board rotates (in rotate command)

3. Replace checkComplications() random logic with threshold checks:
   - Check totalUnitsAdded >= complicationThresholds.lights → spawn LIGHTS
   - Check totalRotations >= complicationThresholds.controls → spawn CONTROLS
   - Check totalUnitsPopped >= complicationThresholds.laser → spawn LASER
   - After spawning, increment threshold by base value (so next trigger is higher)
   - Only spawn if that type isn't already active

4. Import the new ComplicationType values (LIGHTS, CONTROLS, LASER)
  </action>
  <verify>Run tests: `npm run test:run` — all 36 tests pass</verify>
  <done>Counters increment during gameplay, complications trigger at thresholds instead of randomly</done>
</task>

<task type="auto">
  <name>Task 3: Track counter increments at correct game events</name>
  <files>core/GameEngine.ts, core/commands/actions.ts</files>
  <action>
1. Find where pieces lock to grid (in tick() after lock delay) and increment totalUnitsAdded by piece cell count

2. Find where goop is popped (likely in a pop command or handler) and increment totalUnitsPopped by group size

3. Find where board rotates (RotateBoardCommand or similar) and increment totalRotations by 1

4. Ensure counters persist across the run (don't reset except in startRun)

Note: Check if pop/rotate logic is in GameEngine methods or in commands. Increment in the right place.
  </action>
  <verify>
Add console.log temporarily to verify counters increment:
- Place piece → totalUnitsAdded increases
- Pop goop → totalUnitsPopped increases
- Rotate tank → totalRotations increases
Then remove console.logs and run tests: `npm run test:run`
  </verify>
  <done>All three counters increment correctly during gameplay, triggering complications at thresholds</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:run` passes all 36 tests
- [ ] TypeScript compiles: `npx tsc --noEmit`
- [ ] Counters increment during manual gameplay testing
- [ ] Complications spawn at threshold (not randomly)
</verification>

<success_criteria>

- ComplicationType has LIGHTS, CONTROLS, LASER values
- GameState tracks totalUnitsAdded, totalUnitsPopped, totalRotations
- Counters increment at correct game events
- Complications spawn based on thresholds, not 5% random
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-complications/03-01-SUMMARY.md`
</output>
