---
phase: 17-mixer-band
plan: 02
type: execute
---

<objective>
Implement GOOP_HOLD_VIEWER and GOOP_WINDOW features for piece preview.

Purpose: Let players see what piece they're holding and what's coming next.
Output: Hold piece and next piece preview boxes appear in UI when respective upgrades are owned.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-mixer-band/17-01-PLAN.md

**Key files:**
@constants.ts (UPGRADES.GOOP_HOLD_VIEWER at rank 22, UPGRADES.GOOP_WINDOW at rank 28)
@types.ts (GameState has storedPiece: PieceDefinition | null)
@core/GameEngine.ts (needs nextPiece tracking for GOOP_WINDOW)
@components/GameBoard.tsx (render piece previews)

**GOOP_HOLD_VIEWER (rank 22):**
- Feature upgrade, level 1 max
- Shows the storedPiece (held goop) in a small preview box
- Already have storedPiece in state - just need UI

**GOOP_WINDOW (rank 28):**
- Feature upgrade, level 1 max
- Shows the next goop piece that will spawn
- Need to track "nextPiece" in GameState
- On spawn, current nextPiece becomes activePiece, generate new nextPiece

**UI positioning:**
- Hold piece: top-left corner of game board
- Next piece: top-right corner of game board
- Small preview boxes (~3x3 block size)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add nextPiece tracking to GameState and GameEngine</name>
  <files>types.ts, core/GameEngine.ts</files>
  <action>
1. In types.ts, add to GameState interface:
```typescript
nextPiece: PieceDefinition | null;  // Preview of upcoming piece
```

2. In GameEngine.ts constructor, initialize:
```typescript
nextPiece: null,
```

3. In GameEngine.startRun(), after initializing storedPiece, also initialize nextPiece:
```typescript
// Generate first "next piece" for preview
const nextPieceDef = {
    ...PIECES[Math.floor(Math.random() * PIECES.length)],
    color: palette[Math.floor(Math.random() * palette.length)]
};
// In state reset:
nextPiece: nextPieceDef,
```

4. In GameEngine.spawnNewPiece(), if pieceDef is not provided:
   - Use state.nextPiece as the new piece (if available)
   - Generate a new nextPiece for the queue
```typescript
// If no specific piece provided and we have a queued next piece, use it
let pieceToSpawn = pieceDef;
if (!pieceToSpawn && this.state.nextPiece) {
    pieceToSpawn = this.state.nextPiece;
    // Generate new next piece
    const newNext = {
        ...PIECES[Math.floor(Math.random() * PIECES.length)],
        color: palette[Math.floor(Math.random() * palette.length)]
    };
    this.state.nextPiece = newNext;
}
const piece = spawnPiece(pieceToSpawn, currentRank);
```
  </action>
  <verify>Run `npm run test:run`. Check that nextPiece is populated after startRun().</verify>
  <done>GameState tracks nextPiece, spawning uses queued piece</done>
</task>

<task type="auto">
  <name>Task 2: Create PiecePreview component</name>
  <files>components/PiecePreview.tsx (new)</files>
  <action>
Create a small reusable component to render a piece preview:

```typescript
import React from 'react';
import { PieceDefinition } from '../types';

interface PiecePreviewProps {
  piece: PieceDefinition | null;
  label: string;  // "HOLD" or "NEXT"
  visible: boolean;  // Show/hide based on upgrade ownership
}

export const PiecePreview: React.FC<PiecePreviewProps> = ({ piece, label, visible }) => {
  if (!visible || !piece) return null;

  // Calculate piece bounds for centering
  const minX = Math.min(...piece.cells.map(c => c.x));
  const maxX = Math.max(...piece.cells.map(c => c.x));
  const minY = Math.min(...piece.cells.map(c => c.y));
  const maxY = Math.max(...piece.cells.map(c => c.y));
  const width = maxX - minX + 1;
  const height = maxY - minY + 1;

  const cellSize = 16;
  const padding = 8;
  const boxWidth = Math.max(width, 2) * cellSize + padding * 2;
  const boxHeight = Math.max(height, 2) * cellSize + padding * 2 + 16; // +16 for label

  return (
    <div style={{
      background: 'rgba(0,0,0,0.7)',
      border: '2px solid #334155',
      borderRadius: '4px',
      padding: '4px',
      minWidth: boxWidth,
      minHeight: boxHeight
    }}>
      <div style={{
        fontSize: '10px',
        color: '#94a3b8',
        textAlign: 'center',
        marginBottom: '4px'
      }}>
        {label}
      </div>
      <svg
        width={Math.max(width, 2) * cellSize}
        height={Math.max(height, 2) * cellSize}
        style={{ display: 'block', margin: '0 auto' }}
      >
        {piece.cells.map((cell, i) => (
          <rect
            key={i}
            x={(cell.x - minX) * cellSize + (Math.max(width, 2) - width) * cellSize / 2}
            y={(cell.y - minY) * cellSize + (Math.max(height, 2) - height) * cellSize / 2}
            width={cellSize - 2}
            height={cellSize - 2}
            fill={piece.color}
            rx={2}
          />
        ))}
      </svg>
    </div>
  );
};
```
  </action>
  <verify>TypeScript compiles without errors.</verify>
  <done>PiecePreview component created and renders piece shapes</done>
</task>

<task type="auto">
  <name>Task 3: Add piece previews to GameBoard</name>
  <files>components/GameBoard.tsx, Game.tsx</files>
  <action>
1. In Game.tsx, pass new props to GameBoard:
```typescript
storedPiece={engine.state.storedPiece}
nextPiece={engine.state.nextPiece}
```

2. In GameBoard.tsx:
   - Import PiecePreview component
   - Accept new props: storedPiece, nextPiece
   - Determine visibility based on powerUps:
```typescript
const showHoldViewer = (powerUps?.['GOOP_HOLD_VIEWER'] || 0) >= 1;
const showNextWindow = (powerUps?.['GOOP_WINDOW'] || 0) >= 1;
```

3. Render preview boxes in the SVG or as absolute positioned overlays:
```tsx
{/* Piece Preview - Hold (top-left) */}
<div style={{ position: 'absolute', top: '8px', left: '8px', zIndex: 10 }}>
  <PiecePreview piece={storedPiece} label="HOLD" visible={showHoldViewer} />
</div>

{/* Piece Preview - Next (top-right) */}
<div style={{ position: 'absolute', top: '8px', right: '8px', zIndex: 10 }}>
  <PiecePreview piece={nextPiece} label="NEXT" visible={showNextWindow} />
</div>
```

Note: GameBoard container needs position: relative for absolute children.
  </action>
  <verify>Run `npm run test:run`. Visual test: at rank 22+ with GOOP_HOLD_VIEWER, hold box shows. At rank 28+ with GOOP_WINDOW, next box shows.</verify>
  <done>Hold and Next piece previews appear when respective upgrades owned</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:run` passes all tests
- [ ] No TypeScript errors
- [ ] GOOP_HOLD_VIEWER shows held piece at rank 22+
- [ ] GOOP_WINDOW shows next piece at rank 28+
- [ ] Previews don't appear when upgrades not owned
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Both piece preview features work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/17-mixer-band/17-02-SUMMARY.md` with:
- What was built
- Any deviations from plan
- Files modified
</output>
