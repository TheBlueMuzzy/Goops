---
phase: 26.1-flatten-coordinate-system
plan: 02
type: execute
---

<objective>
Add cylindrical wrapping support to the soft-body goop (SBG) physics system.

Purpose: SBG currently treats the viewport as a rectangular box with hard walls. When blobs approach the visible edge (visX 0 or 11) and the tank rotates, vertices clamp at ±180 pixels instead of wrapping around. The original goop systems handle this via modulo/wrapping logic, but SBG lacks this entirely.

Output: SBG blobs seamlessly wrap around the tank cylinder, maintaining visual coherence when crossing the viewport edges and the actual seam (gridX 29→0).
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Key source files:
@core/softBody/physics.ts - boundary constraints (the problem)
@hooks/useSoftBodyPhysics.ts - rotation shift logic
@components/GameBoard.tsx - centroid calculation, blob sync
@utils/goopRenderer.ts - how original goop handles wrapping (reference)

**Problem:**
- `applyBoundaryConstraints()` clamps vertices to `minX=-180, maxX=180` (hard walls)
- When tank rotates and blob shifts past edge, vertices squish against the wall
- Centroid calculation uses arithmetic mean of pixel positions (breaks when cells span seam)
- No mechanism to render blobs that straddle the visible edge

**How original goop solves it:**
- Locked goop: Grid lookup with `normalizeX()` modulo - cells appear/disappear naturally
- Loose goop: Explicit wrapping checks (`if visX > 15, visX -= 30`)
- Both recalculate positions fresh each frame (no persistent pixel positions)

**SBG constraint:**
- SBG uses persistent vertex positions in pixel space
- Must wrap positions, not just recalculate from grid
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cylindrical wrapping constants</name>
  <files>core/softBody/blobFactory.ts</files>
  <action>
Add constants for the cylindrical world width:

```ts
// Cylindrical wrapping - the tank is 30 columns wide in game logic
// but we only see 12 columns at a time. The full cylinder in pixels:
export const CYLINDER_WIDTH_PIXELS = TANK_WIDTH * PHYSICS_CELL_SIZE;  // 30 * 30 = 900

// Visible viewport width in pixels
export const VIEWPORT_WIDTH_PIXELS = TANK_VIEWPORT_WIDTH * PHYSICS_CELL_SIZE;  // 12 * 30 = 360
```

Import `TANK_WIDTH` from constants if not already imported.
  </action>
  <verify>`npm run build` passes</verify>
  <done>Cylindrical constants defined</done>
</task>

<task type="auto">
  <name>Task 2: Create wrap-aware position helpers</name>
  <files>core/softBody/physics.ts</files>
  <action>
Add helper functions for cylindrical wrapping:

```ts
import { CYLINDER_WIDTH_PIXELS, VIEWPORT_WIDTH_PIXELS, PHYSICS_GRID_OFFSET } from './blobFactory';

/**
 * Wrap a pixel X position to stay within the viewport range.
 * When a vertex goes past one edge, it wraps to the other side.
 *
 * The visible range is [-180, 180] (VIEWPORT_WIDTH_PIXELS centered at 0).
 * But the cylinder is 900px wide, so positions can be anywhere in that range.
 * This normalizes to the visible range by adding/subtracting cylinder width.
 */
export function wrapPixelX(x: number): number {
  const minX = PHYSICS_GRID_OFFSET.x;  // -180
  const maxX = minX + VIEWPORT_WIDTH_PIXELS;  // 180

  // Wrap to closest position within one cylinder width of visible area
  while (x < minX - CYLINDER_WIDTH_PIXELS / 2) x += CYLINDER_WIDTH_PIXELS;
  while (x > maxX + CYLINDER_WIDTH_PIXELS / 2) x -= CYLINDER_WIDTH_PIXELS;

  return x;
}

/**
 * Calculate the shortest distance between two X positions on the cylinder.
 * Handles wrap-around: distance from x=170 to x=-170 is 20, not 340.
 */
export function cylindricalDistanceX(x1: number, x2: number): number {
  let dx = x2 - x1;

  // If the direct distance is more than half the cylinder, go the other way
  if (dx > CYLINDER_WIDTH_PIXELS / 2) dx -= CYLINDER_WIDTH_PIXELS;
  if (dx < -CYLINDER_WIDTH_PIXELS / 2) dx += CYLINDER_WIDTH_PIXELS;

  return dx;
}
```
  </action>
  <verify>`npm run build` passes</verify>
  <done>Wrap-aware position helpers created</done>
</task>

<task type="auto">
  <name>Task 3: Replace hard boundaries with cylindrical wrapping</name>
  <files>core/softBody/physics.ts</files>
  <action>
Modify `applyBoundaryConstraints()` to wrap horizontally instead of clamping:

```ts
export function applyBoundaryConstraints(blobs: SoftBlob[], bounds: Bounds): void {
  const MARGIN = 2;
  const BOUNDARY_DAMPING = 0.3;

  for (const blob of blobs) {
    for (const v of blob.vertices) {
      // HORIZONTAL: Wrap around cylinder (no hard walls)
      v.pos.x = wrapPixelX(v.pos.x);
      v.oldPos.x = wrapPixelX(v.oldPos.x);

      // VERTICAL: Keep hard floor/ceiling (top/bottom of tank)
      // Top wall
      if (v.pos.y < bounds.minY + MARGIN) {
        v.pos.y = bounds.minY + MARGIN;
        const vy = v.pos.y - v.oldPos.y;
        v.oldPos.y = v.pos.y - vy * BOUNDARY_DAMPING;
      }
      // Bottom wall
      if (v.pos.y > bounds.maxY - MARGIN) {
        v.pos.y = bounds.maxY - MARGIN;
        const vy = v.pos.y - v.oldPos.y;
        v.oldPos.y = v.pos.y - vy * BOUNDARY_DAMPING;
      }
    }

    // Also wrap inner vertices if they exist
    for (const v of blob.innerVertices) {
      v.pos.x = wrapPixelX(v.pos.x);
      v.oldPos.x = wrapPixelX(v.oldPos.x);

      if (v.pos.y < bounds.minY + MARGIN) {
        v.pos.y = bounds.minY + MARGIN;
      }
      if (v.pos.y > bounds.maxY - MARGIN) {
        v.pos.y = bounds.maxY - MARGIN;
      }
    }
  }
}
```

This removes the left/right wall clamping entirely and replaces with wrapping.
  </action>
  <verify>`npm run build` passes</verify>
  <done>Boundary constraints use cylindrical wrapping horizontally</done>
</task>

<task type="auto">
  <name>Task 4: Update spring forces to use cylindrical distance</name>
  <files>core/softBody/physics.ts</files>
  <action>
Find the spring constraint functions and update to use cylindrical distance for X.

In `applySprings()` or similar, when calculating distance between two vertices:

```ts
// OLD: Direct distance
const dx = v2.pos.x - v1.pos.x;

// NEW: Cylindrical distance (shortest path around cylinder)
const dx = cylindricalDistanceX(v1.pos.x, v2.pos.x);
```

Apply this to:
1. Edge springs (perimeter constraints)
2. Structural springs (if any)
3. Home force calculations
4. Any other distance calculations between vertices

The key insight: when a spring connects vertices at x=170 and x=-170, the shortest path is 20px across the wrap, not 340px the long way.
  </action>
  <verify>`npm run build` passes</verify>
  <done>Spring forces respect cylindrical geometry</done>
</task>

<task type="auto">
  <name>Task 5: Create wrap-aware centroid calculation</name>
  <files>components/GameBoard.tsx</files>
  <action>
The current centroid calculation breaks when cells span the seam.

Example: cells at visX=[10, 11, 0, 1] should centroid near the edge, not at visX=5.5.

Replace the arithmetic mean with a wrap-aware calculation:

```ts
// Helper: Calculate centroid of points that may wrap around the cylinder
function calculateWrappedCentroidX(cells: Vec2[]): number {
  if (cells.length === 0) return 0;

  const CELL_SIZE = 30;
  const OFFSET_X = -180;
  const VIEWPORT_COLS = 12;
  const CYLINDER_COLS = 30;

  // Use circular mean: convert to angles, average, convert back
  // This handles wrap-around correctly
  let sumSin = 0;
  let sumCos = 0;

  for (const cell of cells) {
    // Convert visX to angle (0-360 degrees mapped to 0-30 columns)
    const angle = (cell.x / CYLINDER_COLS) * 2 * Math.PI;
    sumSin += Math.sin(angle);
    sumCos += Math.cos(angle);
  }

  // Average angle
  const avgAngle = Math.atan2(sumSin / cells.length, sumCos / cells.length);

  // Convert back to visX (handle negative angles)
  let avgVisX = (avgAngle / (2 * Math.PI)) * CYLINDER_COLS;
  if (avgVisX < 0) avgVisX += CYLINDER_COLS;

  // Now normalize to visible range (0-11) for pixel calculation
  // If centroid is outside visible range, wrap it
  if (avgVisX >= VIEWPORT_COLS) {
    avgVisX -= CYLINDER_COLS;  // Wrap to negative side
  }

  // Convert to pixel X
  return OFFSET_X + (avgVisX + 0.5) * CELL_SIZE;
}
```

Use this in the blob position sync loop instead of arithmetic mean.
  </action>
  <verify>`npm run build` passes</verify>
  <done>Centroid calculation handles wrapped cells correctly</done>
</task>

<task type="auto">
  <name>Task 6: Update rotation shift to wrap positions</name>
  <files>hooks/useSoftBodyPhysics.ts</files>
  <action>
In `shiftBlobsForRotation()`, after shifting vertices by pixel offset, wrap them:

```ts
import { wrapPixelX } from '../core/softBody/physics';

const shiftBlobsForRotation = useCallback((newRotation: number) => {
  for (const blob of blobsRef.current) {
    const delta = newRotation - blob.createdAtRotation;
    const pixelOffset = -delta * PHYSICS_CELL_SIZE;

    // Shift and wrap all vertices
    for (const v of blob.vertices) {
      v.pos.x = wrapPixelX(v.pos.x + pixelOffset);
      v.oldPos.x = wrapPixelX(v.oldPos.x + pixelOffset);
    }
    for (const v of blob.innerVertices) {
      v.pos.x = wrapPixelX(v.pos.x + pixelOffset);
      v.oldPos.x = wrapPixelX(v.oldPos.x + pixelOffset);
    }

    // Update and wrap target position
    blob.targetX = wrapPixelX(blob.targetX + pixelOffset);

    blob.createdAtRotation = newRotation;
  }
}, []);
```
  </action>
  <verify>`npm run build` passes</verify>
  <done>Rotation shifts wrap vertex positions</done>
</task>

<task type="auto">
  <name>Task 7: Handle rendering of edge-straddling blobs</name>
  <files>components/GameBoard.tsx</files>
  <action>
When a blob's vertices span the wrap boundary (some near -180, some near +180), the SVG path will draw a line across the entire screen instead of wrapping.

Solution: Detect edge-straddling blobs and render them twice (once on each side).

In `getBlobVertexPath()` or the blob rendering section:

```ts
function getBlobRenderData(blob: SoftBlob): { paths: string[], transforms: string[] } {
  const verts = blob.vertices;
  if (verts.length < 3) return { paths: [], transforms: [] };

  // Check if blob straddles the wrap boundary
  const minX = Math.min(...verts.map(v => v.pos.x));
  const maxX = Math.max(...verts.map(v => v.pos.x));
  const WRAP_THRESHOLD = 300;  // If span > this, blob is straddling

  if (maxX - minX > WRAP_THRESHOLD) {
    // Blob straddles - render twice
    // Once at current position, once shifted by cylinder width
    const CYLINDER_WIDTH = 900;

    const path = buildPathFromVerts(verts);
    return {
      paths: [path, path],
      transforms: ['', `translate(${CYLINDER_WIDTH}, 0)`]  // Second copy shifted right
    };
  }

  // Normal case - single render
  return {
    paths: [buildPathFromVerts(verts)],
    transforms: ['']
  };
}

function buildPathFromVerts(verts: Vertex[]): string {
  let path = `M ${verts[0].pos.x} ${verts[0].pos.y}`;
  for (let i = 1; i < verts.length; i++) {
    path += ` L ${verts[i].pos.x} ${verts[i].pos.y}`;
  }
  path += ' Z';
  return path;
}
```

Render each path with its transform. The SVG viewBox clips to visible area, so the shifted copy only shows the wrapped portion.
  </action>
  <verify>`npm run build` passes</verify>
  <done>Edge-straddling blobs render correctly on both sides</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Cylindrical wrapping for soft-body goop physics</what-built>
  <how-to-verify>
    1. Run: `npm run dev -- --host`
    2. Open game, start at any rank
    3. Lock a piece near the right edge of the tank
    4. Rotate the tank RIGHT (piece moves left in view)
    5. **Key test:** As the blob approaches the LEFT edge (visX=0), it should NOT clump/squish
    6. Continue rotating - blob should seamlessly wrap and appear on the right edge
    7. Test the reverse: lock piece on left, rotate left, should wrap to right
    8. Use backtick → Show Vertices to see the physics vertices wrapping correctly
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run test:run` passes all tests
- [ ] Blobs near edges don't clump when tank rotates
- [ ] Blobs seamlessly wrap from left edge to right edge and vice versa
- [ ] Spring physics work correctly across the wrap boundary
- [ ] No visual glitches when blob straddles the viewport edge
</verification>

<success_criteria>
- Hard boundary constraints replaced with cylindrical wrapping
- Spring forces use shortest cylindrical distance
- Centroid calculation handles cells spanning the seam
- Edge-straddling blobs render correctly on both sides
- Smooth visual continuity when rotating blobs around the tank
</success_criteria>

<output>
After completion, create `.planning/phases/26.1-flatten-coordinate-system/26.1-02-SUMMARY.md`

# Phase 26.1 Plan 02: Cylindrical Wrapping for SBG Summary

**[Substantive one-liner]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions and rationale]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Resume Phase 26-02 (soft-body blob rendering) with fully working cylindrical coordinate system
</output>
